<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>尼孟尼克 Blog</title>
  <icon>https://www.gravatar.com/avatar/3fc7f0484ec48b2da08be4c167579713</icon>
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://charlesliuyx.github.io/"/>
  <updated>2017-09-25T18:56:19.000Z</updated>
  <id>https://charlesliuyx.github.io/</id>
  
  <author>
    <name>Nimonic</name>
    <email>297106826@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>评估竞争币的价值与智能合约</title>
    <link href="https://charlesliuyx.github.io/2017/09/25/%E8%AF%84%E4%BC%B0%E7%AB%9E%E4%BA%89%E5%B8%81%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    <id>https://charlesliuyx.github.io/2017/09/25/评估竞争币的价值与智能合约/</id>
    <published>2017-09-25T18:54:40.000Z</published>
    <updated>2017-09-25T18:56:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】<br>【内容简介】<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】&lt;br&gt;【内容简介】&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="BlockChain" scheme="https://charlesliuyx.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="https://charlesliuyx.github.io/tags/BlockChain/"/>
    
      <category term="Ethereum" scheme="https://charlesliuyx.github.io/tags/Ethereum/"/>
    
  </entry>
  
  <entry>
    <title>一文弄懂区块链-以比特币为例</title>
    <link href="https://charlesliuyx.github.io/2017/09/24/%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82%E5%8C%BA%E5%9D%97%E9%93%BE-%E4%BB%A5%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BA%E4%BE%8B/"/>
    <id>https://charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/</id>
    <published>2017-09-24T22:09:42.000Z</published>
    <updated>2017-09-25T18:57:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】25min - 35min<br>【内容简介】此文潜在面向群体是对区块链或比特币的运行原理完全不了解的人。所以会从<strong>用户需求</strong>的角度出发，<strong>一步一步发明区块链</strong>，在此之后的内容会涉及一些思考和技术上的原理延伸，可以选择性阅读<br><a id="more"></a></p><h1 id="加密货币"><a href="#加密货币" class="headerlink" title="加密货币"></a>加密货币</h1><p>在一步一步发明发明比特币之前，有一些基本直观的认知需要阐明。</p><p>我们常说的比特币，是<strong>加密货币（Cryptocurrency）</strong>的一种，而加密货币<strong>实现去中心化</strong>的最关键的技术是<strong>区块链</strong></p><p>有些地方可能把加密货币又称为数字货币（或称电子货币），但实际上，加密货币是数字货币的子集，同为子集的还有<strong>虚拟货币</strong>（如Q币），<strong>加密货币</strong>的称谓要更加专业</p><p>加密货币一定具有下列三个特点</p><ul><li><strong>去中心的清算</strong></li><li><strong>分布式的记账</strong></li><li><strong>离散化的支付</strong></li></ul><p><strong>为了实现这些特点</strong>，需要使用到<strong>区块链技术</strong>。这里的区块链技术是一个很广义的范畴，它包含了密码学，算法等很多不同的内容，其中最精彩的点子，可算是<strong>工作量证明 = 共识信用</strong>了</p><h1 id="一步一步发明比特币"><a href="#一步一步发明比特币" class="headerlink" title="一步一步发明比特币"></a>一步一步发明比特币</h1><h2 id="第一个用户需求-账本和电子签名的由来"><a href="#第一个用户需求-账本和电子签名的由来" class="headerlink" title="第一个用户需求 - 账本和电子签名的由来"></a>第一个用户需求 - 账本和电子签名的由来</h2><blockquote><p>第一个用户需求描述了<strong>中心化清算系统</strong>几个关键内容的由来，只对区块链感兴趣的读者可以跳过</p></blockquote><p>经济体的蓬勃发展离不开<strong>交易</strong>。在交易过程中，人们早已发现使用一般等价物（如金银）十分麻烦，发明了纸币（北宋时代四川地区的纸币交子的<strong>清算体系</strong>），而最终，<strong>携带现金也很麻烦</strong></p><p>这是第一个基本用户需求：<strong>摆脱现金进行交易带来的不方便</strong></p><p><strong>【解决办法】</strong>几个用户使用<strong>公共账本</strong>记录转账记录，<strong>月底结算</strong>，并且<strong>账本是公开的</strong>，每个人都可以修改，也就是说可以在上面添加行，如<code>小明转账给小红10块钱</code></p><h3 id="产生的问题1：身份问题"><a href="#产生的问题1：身份问题" class="headerlink" title="产生的问题1：身份问题"></a>产生的问题1：身份问题</h3><p>在这个账本中我们无法确认条目<code>小明</code>和<code>小红</code>是否真实，可能出现欺诈现象</p><p><strong>【解决办法】</strong>使用电子签名，即公钥 - 私钥对</p><p>过程解释为，<code>小明</code>使用自己的私钥（一个字符串）通过<strong>一连串的计算</strong>（加密函数）产生一个公钥（一串字符串），作为签名（一个字符串），验证过程是对<strong>签名和公钥</strong>进行<strong>一连串计算</strong>（验证函数）进行验证（输出为真/假，真为签名有效，证明这个公钥的确能证明这是<code>小明</code>的）</p><p>直观结果是，我们可以利用<strong>密码学的手段</strong>，保证<code>小明</code>的<strong>身份能被100%确认真实</strong></p><p>但是这个解决方案有一个小漏洞：可以复制同一行信息来伪造交易记录，解决的办法是添加一个<strong>这笔交易独有的信息（比如时间戳）</strong></p><h3 id="产生的问题2：欠债跑路问题"><a href="#产生的问题2：欠债跑路问题" class="headerlink" title="产生的问题2：欠债跑路问题"></a>产生的问题2：欠债跑路问题</h3><p>如果<code>小明</code>在此时账户上已经没有足够的余额进行支付，就会出现超支问题</p><p><strong>【解决办法】</strong>添加余额记录，此时就不可避免的需要一个<strong>中间担保人（国家？信誉机构？银行？）</strong>为<code>小明</code>进行余额担保</p><h3 id="一个大家都遵守的协议"><a href="#一个大家都遵守的协议" class="headerlink" title="一个大家都遵守的协议"></a>一个大家都遵守的协议</h3><p>此时，现代金融体系的框架基本建立完毕，协议内容是</p><ul><li>任何人都可以在<strong>账本上添加新行</strong></li><li>固定时间间隔时用<strong>真金白银进行清算</strong></li><li>只有有<strong>签名的交易</strong>是有效的</li><li>中间担保的人<strong>保证不可超支</strong></li></ul><p>此时发现一个很有趣的很容，这个比较严谨的协议有一个特点：<strong>如果所有人都按照这个协议来办事，我们可以永任何形式的东西来代替人民币了</strong>，换句话说，就是我根本不关心你在账本上添加的新行的交易内容是什么，可以是任何东西</p><p>利用这个提出需求再解决问题的过程，强化一个<strong>认知</strong>：<strong>货币 = 交易记录（账本），即货币的本质是交易记录</strong>，在这背后，有一个前提是，货币的另一个本质是一种<strong>共识</strong>，我们都信任的它有价值的共识</p><h2 id="第二个用户需求：账本放在哪里？"><a href="#第二个用户需求：账本放在哪里？" class="headerlink" title="第二个用户需求：账本放在哪里？"></a>第二个用户需求：账本放在哪里？</h2><p>传统的（现在的）解决方案当时是，使用中心代理-<strong>银行</strong>，来存放账本</p><p>既然是第二个用户需求，那肯定就是因为现在的解决方案大家都<strong>不满意</strong></p><h3 id="核心需求：去中心化"><a href="#核心需求：去中心化" class="headerlink" title="核心需求：去中心化"></a>核心需求：去中心化</h3><p>中心化的痛点大致可以说几点</p><ul><li>银行<strong>效率低下</strong>，一笔跨国转账的等待时间较长</li><li><strong>胖银行金融体系</strong>因部分准备金制度等等方便的规则，能抬升杠杆，产生金融泡沫，进一步诱发金融危机</li><li><strong>私有财产神圣不可侵犯</strong>是精英与平民，剥削与被剥削者几个世纪以来讨论的核心</li></ul><p>当然还有很多没有提到，总之，是一种一直饱受诟病的清算方式，此时，中本聪在2009年横空出世，他提出了一种全新的<strong>清算方法</strong>，并且真正解决的信用的问题！接下来就是真正的一步一步的发明比特币的过程了</p><h3 id="如何实现分布记账（去中心化）"><a href="#如何实现分布记账（去中心化）" class="headerlink" title="如何实现分布记账（去中心化）"></a>如何实现分布记账（去中心化）</h3><p>为了去中心化，我们可以反其道而行之：每个用户保存账本，分布记账。用户产生一笔交易就讲这笔交易广播到到网络上所有的节点上，这样不就完美的去中心化了？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/broadcast.gif" alt="广播模式分布式账本示意图" title="">                </div>                <div class="image-caption">广播模式分布式账本示意图</div>            </figure><p>只要是明眼人都能发现，太天真的，这个方法行不通。可以，行不通，那就把行不通的原因总结出来</p><blockquote><p>遇到问题，总结不可行的原因，寻找解决方案。这是整个人类不断前进的核心最小单位</p></blockquote><h4 id="问题核心"><a href="#问题核心" class="headerlink" title="问题核心"></a>问题核心</h4><font color="FF0000">如何让所有人都同意这个新账本？如何保持这些账本同步？有一笔交易发生时，如何让其他人都听到并相信这一笔交易呢？</font><p>这些问题才是真正的核心：<strong>是否能在协议（办法，规则）中添加几行，找到办法，来决定是否接受交易，并确定交易顺序，使你可以放心的相信，世界上遵守同一协议的所有人手上的账本都和你的一模一样呢？</strong>（问题描述值得品读，只有抽象出问题才能更好的去寻找解决方案）</p><h4 id="☆解决方案"><a href="#☆解决方案" class="headerlink" title="☆解决方案"></a>☆解决方案</h4><p>解决的思路是：哪个账本的<strong>计算工作量大</strong>，就信任哪个账本。换个角度来说是<strong>让交易欺诈和账本不一的情形的计算力成本高到不能接受甚至完全不可行</strong></p><h5 id="1、密码学：哈希函数"><a href="#1、密码学：哈希函数" class="headerlink" title="1、密码学：哈希函数"></a>1、密码学：哈希函数</h5><p>哈希函数，<strong>输入</strong>可以是任意信息或者文件，<strong>输出</strong>是固定长度的比特串，例如256bit的1/0串，这个输出叫做这个信息的<strong>“哈希值”或者“摘要”（digest）</strong>。比如SHA256就是一个哈希函数</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/hashfunction.gif" alt="密码哈希函数的特点" title="">                </div>                <div class="image-caption">密码哈希函数的特点</div>            </figure><p>密码哈希函数有几个特点</p><ul><li>特点是<strong>输入值稍微变化后，结果就会有很大的不同，完全无法预测不同输入间的规律</strong></li><li><strong>逆向计算</strong>不可行，只能使用试错法（穷举法），解空间 $2^{256}$ </li></ul><p>在每一个账本后添加一个<strong>特殊数字</strong>，对整个列表使用SHA256，我们要求这个<strong>特殊数字</strong>可以使得输出值的开头有<strong>30个零</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/30zero2.gif" alt="寻找能使得输出前30位为0的特殊数字" title="">                </div>                <div class="image-caption">寻找能使得输出前30位为0的特殊数字</div>            </figure><p>根据之前说过SHA256的性质：输入变化输出不可预测，找到这个特殊数字唯一的办法就是穷举。换言之，你很容易就证明了他们<strong>进行了海量的计算</strong>。而这个<strong>特殊数字就叫做工作量证明</strong>（proof of work）</p><p>这就意味着，所有的工作量证明就对应了交易列表，如果你修改了一个交易，哪怕只有一点点，就会完全改变哈希值，就得<strong>重做工作量证明</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/30zerochange.gif" alt="修改后的重新计算" title="">                </div>                <div class="image-caption">修改后的重新计算</div>            </figure><h5 id="2、区块链-信用的共识的基石"><a href="#2、区块链-信用的共识的基石" class="headerlink" title="2、区块链 - 信用的共识的基石"></a>2、区块链 - 信用的共识的基石</h5><p>每一个小账本被称为区块，<strong>每一个不同的区块链协议（产生不同的加密货币）</strong>都会规定每一个区块所能包含的<strong>交易数量</strong>（1M or 2M it’s a question，当年中本聪谜一般的通过一次Clear up标记的Commit把相当重要的区块容量从32M调整为1M的年度大戏，关于区块容量也是一个值得讨论的问题），现在<strong>比特币</strong>每个区块的转账信息大约在2400笔左右    </p><p><strong>账本组成区块，区块构成链表，区块的头包含前一块的哈希值，这就是区块链</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/blockchain1.gif" alt="区块链的诞生" title="">                </div>                <div class="image-caption">区块链的诞生</div>            </figure><p>如此一来，任何人就不能随意修改其中的内容，或者交换顺序。如果你这么做，意味着<strong>你需要重新计算所有的特殊数字</strong>，这从概率上来说，是不可能的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/blockchain2.gif" alt="区块链的诞生" title="">                </div>                <div class="image-caption">区块链的诞生</div>            </figure><p><strong>允许世界上的每一个人建造区块</strong>。每一个新建区块的人（找到了这个特殊数字 - SHA256值有40个零）都能获得奖励，对于<strong>新建区块的这部分人（矿工）</strong>来说，以下几点需要注意</p><ul><li>没有发送者信息，不需要签名</li><li>每一个新区块都会给<strong>整个币种增加新的虚拟（加密）货币</strong></li><li>新建区块的过程又被称为“挖矿”：需要大量工作量并且可以向整个经济体注入新的货币</li><li>挖矿的工作是：<strong>接受交易信息，建造区块，把区块广播出去，然后得到新的钱作为奖励</strong></li><li>对每个矿工来说，每个区块就像一个<strong>小彩票</strong>，所有人都在拼命快速猜数字，直到有一个幸运儿找到了一个<strong>特殊数字</strong>，<strong>使得整个区块的哈希值开头有许多个零，就能得到奖励</strong>。我记得有一个知乎答主给了一个形象的比喻，区块链就像一个拥有貌美如花女儿（区块）的国王，有很多的青年翘首以盼，而国王的方法是<strong>出了一道很难得题目</strong>让所有的青年计算（学习改变人生），谁算的快（在计算哈希值过程也可能是运气好）就能抱得美人归</li><li><strong>对于想用这个系统来收付款的用户来说，他们不需要收听所有的交易，而只要收听矿工们广播出来的区块，然后更新到自己保存的区块链中就可以了</strong></li></ul><h5 id="3、51-算力-共识攻击问题"><a href="#3、51-算力-共识攻击问题" class="headerlink" title="3、51%算力-共识攻击问题"></a>3、51%算力-共识攻击问题</h5><p>这里有一个小漏洞，因为网络的延迟或者有人在篡改区块链等因素，你作为一个收听网络广播的用户，如果同时接受到两条不同的区块链怎么办？其中的交易信息发生了冲突</p><blockquote><p>注：区块链本身就是最终的大账本，发生交易的唯一方法就是把你的交易加入到大账本上。具体来说，就是让矿工把你的交易记录加入它新挖到的区块中，并把这个区块链接到区块链上，链接的纽带，当然就是工作量证明</p></blockquote><p>对于上面问题，用户的解决方案也比较简单：即，<strong>只保留最长的，也就是包含的工作量最大的那一条</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/bloackchain-conflict.gif" alt="用户保留最长的区块链" title="">                </div>                <div class="image-caption">用户保留最长的区块链</div>            </figure><p>这里有一个Trick，<strong>即所谓信任工作量最大不仅仅是出【一道难题】，还通过等待多个区块的产生引入世界上所有矿工之间的博弈</strong>（吃瓜群众，坐看大戏，谁厉害我选谁，你们尽管斗）</p><p>个人观点：区块链的Idea最核心的创新就是从技术上把<strong>信任和贪婪画了等号</strong>。<font color="“FF0000”">因为贪婪</font>（希望去竞争建立区块的建立和交易费）<font color="“FF0000”">所以信任</font>（全网算力越大，用户越放心），这句话甚至带上了些许哲学和传奇的色彩</p><p>对于用户来说，是这样一种情景</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/bloackchain-trust.gif" alt="如何更新本地区块链" title="">                </div>                <div class="image-caption">如何更新本地区块链</div>            </figure><p>其中的原因是，你可以假设Alice希望篡改一个交易信息，那么就意味着Alice需要不断的通过计算维护这个区块链了。<strong>也就是说每一次有新的区块链产生，Alice都需要不断的抢到这个彩票</strong>，理论上来说，他至少必须拥有全网51%以上的算力才能做到这一点，更多的，<strong>随着用户等待区块的增加，这个难度，幂次上升</strong>，在7-8个区块链产生后，概率上来讲，就是<strong>绝对信任</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/bloackchain-conflict2.gif" alt="无穷大的篡改成本" title="">                </div>                <div class="image-caption">无穷大的篡改成本</div>            </figure><p>此时</p><ul><li><p>我们用<strong>数字签名</strong>保证了不能伪造交易记录</p></li><li><p>用<strong>区块链以及一些相应的规则</strong>保证了不能篡改其中的信息</p></li></ul><p>这两点，就完成了：<font color="FF0000"><strong>证明区块链的每一条交易记录都是可信的这一终极目标</strong></font></p><h3 id="总结-系统可行性分析"><a href="#总结-系统可行性分析" class="headerlink" title="总结 - 系统可行性分析"></a>总结 - 系统可行性分析</h3><p>只需要思考，<strong>我们如何才能在这个系统下骗人呢</strong>？</p><ul><li>如果你想篡改一笔不存在的交易记录，那么你必须比所有人都算的快，赢得这个彩票</li><li>但<strong>所有用户</strong>会继续收听其他矿工的广播</li><li>所以为了让所有用户继续相信这个伪造的区块</li><li>你必须投入自己所有的工作量，不断给<strong>篡改后的区块链分叉</strong>增添新的区块</li><li><strong>记住：根据协议，所有用户会一直信任他所知道的最长的链</strong></li><li>是的，你不可能<strong>持续的竞争过世界上所有的矿工</strong></li><li>注意，作为一个用户，你不能立马相信你所听到的最新区块，而是应该等待多几个区块被创建过后，再确认这的确是世界所有人都在使用的区块链</li></ul><h2 id="发明过程中的关键点"><a href="#发明过程中的关键点" class="headerlink" title="发明过程中的关键点"></a>发明过程中的关键点</h2><ul><li>电子签名 Digital Signatures</li><li>公共账本就是货币 The Ledger is the currency</li><li>去中心化 Decentralize</li><li>工作量证明 Proof of work</li><li>区块链 Block Chain</li></ul><h1 id="比特币技术"><a href="#比特币技术" class="headerlink" title="比特币技术"></a>比特币技术</h1><p>到这里，已经发明了比特币，解决了去中心化的信任这一难题。只对比特币和区块链是什么这个问题的读者，希望大家可以在我的叙述中解决一些困惑，新技术，新点子，要拥抱它，使用它，<strong>必须先了解它</strong>。</p><p>我们知道区块链中记载的实体，对于比特币（加密货币）来说就是<strong>转账记录</strong>。但是，一个概念真正的跑起来，有很多技术上，协议上的细节也值得稍作了解</p><p>接下里的部分主要探讨一些比特币具体实现方面的细节，如网络节点构成，比特币的计算难度系数，比特币总量的由来，比特币一笔交易发生的内部细节等</p><h2 id="比特币网络节点的构成"><a href="#比特币网络节点的构成" class="headerlink" title="比特币网络节点的构成"></a>比特币网络节点的构成</h2><p>比特币网络是一种点对点的数字现金系统，IP网络节点中每台机器都彼此对等，P2P网络不存在任何服务端、层级关系或者中心化服务。</p><h3 id="节点类型与分工"><a href="#节点类型与分工" class="headerlink" title="节点类型与分工"></a>节点类型与分工</h3><div align="center"><img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/AllFunctionNode.svg" alt="全功能节点" width="250"></div><p>一个全功能节点包含上述4个模块【钱包<strong>W</strong>allet】【矿工<strong>M</strong>iner】【完整区块链full <strong>B</strong>lock-chain database】【网络路由节点<strong>N</strong>etwork routing】</p><ul><li>【网络路由节点】使得节点具有<strong>参与验证并传播交易与区块信息，发现监听并维持点对点的链接</strong>的能力</li><li>【完整区块链】具有此模块的节点被称为：全节点。它能够<strong>独自自主的校验所有交易</strong>，不需要任何其他信息。</li><li>【钱包】比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的，数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。有些节点仅仅保留<strong>区块链的一部分</strong>，通过一种”简易支付验证“（SPV Simplified Payment Verification）的方法来完成交易</li><li>【矿工】挖矿节点以相互竞争的方式创造新的区块。有一些挖矿节点也是全节点，可以独立挖矿；还有一些参与矿池挖矿的节点是轻量级节点，<strong>必须依赖矿池服务器维护全节点进行工作</strong></li></ul><p>拥有全部四个模块被称之为<strong>核心客户端（Bitcoin Core）</strong>，除了这些主要节点类型外，还有一些服务器及节点运行其他协议，如特殊矿池挖矿协议、轻量级客户端访问协议。</p><p>下表为扩展比特币网络的不同节点类型</p><table><thead><tr><th style="text-align:center">图示</th><th style="text-align:center">名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/SoloMiner.svg" alt="" width="80"></td><td style="text-align:center">独立矿工</td><td style="text-align:center">具有完整区块链副本</td></tr><tr><td style="text-align:center"><img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/FullBlockChainNode.svg" alt="" width="80"></td><td style="text-align:center">完整区块链节点</td><td style="text-align:center">此种节点有时有中继作用，不断收听网络广播，维护完整区块链</td></tr><tr><td style="text-align:center"><img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/SPVwallet.svg" alt="" width="80"></td><td style="text-align:center">轻量(SPV)钱包</td><td style="text-align:center">移动端，或者不想太过于笨重的桌面端，只需要进行交易广播操作</td></tr><tr><td style="text-align:center"><img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/PoolProtocolServers.svg" alt="" width="80"></td><td style="text-align:center">矿池协议服务器</td><td style="text-align:center">将运行其他协议的节点，连接至P2P网络的网关路由器</td></tr><tr><td style="text-align:center"><img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/MiningNodes.svg" alt="" height="80px"></td><td style="text-align:center">挖矿节点</td><td style="text-align:center">不具有区块链，但具备Stratum协议的节点或其他矿池挖矿协议的网络节点</td></tr><tr><td style="text-align:center"><img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/StratumWallet.svg" alt="" width="80"></td><td style="text-align:center">轻量 Stratum 钱包</td><td style="text-align:center">不具有区块链的钱包、运行Stratum协议的网络节点</td></tr></tbody></table><h3 id="扩展比特币网络"><a href="#扩展比特币网络" class="headerlink" title="扩展比特币网络"></a>扩展比特币网络</h3><p>要在全世界的网络中完成整个的交易，下图描述了一个扩展比特币网络，它包含了多重类型的节点、网关服务器、边缘路由器、钱包客户端以及它们互相连接所需要的各类协议，比特币互相连接的接口一般使用<code>8333端口</code></p><p>可以参看这个文章了解Stratum协议，<a href="http://www.8btc.com/stratum_protocol" target="_blank" rel="external">Stratum协议详解</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/BitcoinNet.png" alt="扩展比特币网络" title="">                </div>                <div class="image-caption">扩展比特币网络</div>            </figure><h2 id="如何控制区块产生速度恒定"><a href="#如何控制区块产生速度恒定" class="headerlink" title="如何控制区块产生速度恒定"></a>如何控制区块产生速度恒定</h2><h3 id="难度系数"><a href="#难度系数" class="headerlink" title="难度系数"></a>难度系数</h3><p>我们在发明比特币的过程已经详细说明了<strong>工作量证明</strong>寻找一个特殊数字使得SHA256函数的输出字符串的前<code>n</code>位是零</p><p>对于每一种不同的加密货币来说，都有<strong>一个值</strong>需要在建立货币的时候时候被定义，即<strong>每一个新区块在当前全网算力的条件被发现的【平均时间】</strong>，这也是难度系数的由来</p><blockquote><p> 比特币10分钟；以太坊15秒；瑞波币3.5秒；莱特币2.5分钟</p></blockquote><p>抛开代码算法层面来说，实现方法就是通过找前<code>n</code>位是0的方法。从概率角度来说，n值越大，意味找到这个这个数的解范围越小。</p><p>随着需求<code>0</code>的数目一个一个增加，<strong>需要的计算时间将会程指数增长</strong>。</p><p>那么肯定会问，这个难度值如何动态调整？由谁调整？</p><h3 id="难度调整方式"><a href="#难度调整方式" class="headerlink" title="难度调整方式"></a>难度调整方式</h3><p>难度的调整实在每个完整节点中自动发生的。如果网络发现区块产生速率比10分钟要快时会增加难度。如果发现比10分钟慢时则降低难度。</p><p>例如比特币中的是这样定义的：每2016个区块后计算生成它们花费的时长，比上20160（14天）调整一次。有人可能会问，如果在这十四天内计算能力暴涨怎么办，其实这个10分钟的区块新建间隔的规定也只是一个估计要求，真实情况下，<strong>这个时间会偏离10分钟这个设定值很多，但是这种偏差并不会对整个区块链的运行产生影响</strong></p><h2 id="比特币总量的由来"><a href="#比特币总量的由来" class="headerlink" title="比特币总量的由来"></a>比特币总量的由来</h2><p>我们已经知道，矿工没新建一个区块就可以得到一定数量的比特币作为奖励，最开始，一个区块可以得到<code>50BTC</code>的奖励，之后每210000个区块，奖励减半，直到2140年，所有的比特币将会发放完毕，可以得到公式<br>$$<br>Total = 210000 \times(50 + 25 + 12.5 + \ldots) = 20999999980 \approx \text{2100万}<br>$$<br>而这个规则不同的竞争币种都可以自由设置。但是因为<strong>交易费的存在</strong>，挖矿的人还是会有收益，否则无法建立新的区块，那么整个比特币网络就瘫痪了</p><h2 id="比特币的交易处理能力"><a href="#比特币的交易处理能力" class="headerlink" title="比特币的交易处理能力"></a>比特币的交易处理能力</h2><h3 id="现在比特币区块链的区块信息"><a href="#现在比特币区块链的区块信息" class="headerlink" title="现在比特币区块链的区块信息"></a>现在比特币区块链的区块信息</h3><p>我现在直接从<a href="https://blockchain.info/" target="_blank" rel="external">BLOCKCHAIN</a>上，在我写下这句话的时候，最新的区块是情况</p><table><thead><tr><th style="text-align:center">区块高度</th><th style="text-align:center">存在时间</th><th style="text-align:center">交易数量</th><th style="text-align:center">交易额</th><th style="text-align:center">创建人(矿池)</th><th style="text-align:center">大小(KB)</th><th style="text-align:center">重量(kWU)</th></tr></thead><tbody><tr><td style="text-align:center">486883</td><td style="text-align:center">3分钟</td><td style="text-align:center">2126</td><td style="text-align:center">25992.38</td><td style="text-align:center">BTC.TOP</td><td style="text-align:center">999.34</td><td style="text-align:center">3917.54</td></tr><tr><td style="text-align:center">486882</td><td style="text-align:center">23分钟</td><td style="text-align:center">2422</td><td style="text-align:center">33926.89</td><td style="text-align:center">BTCC Pool</td><td style="text-align:center">1034.39</td><td style="text-align:center">3996.58</td></tr><tr><td style="text-align:center">486881</td><td style="text-align:center">51分钟</td><td style="text-align:center">358</td><td style="text-align:center">4480.22</td><td style="text-align:center">BTC.TOP</td><td style="text-align:center">191.92</td><td style="text-align:center">718.14</td></tr><tr><td style="text-align:center">486880</td><td style="text-align:center">53分钟</td><td style="text-align:center">352</td><td style="text-align:center">3770.26</td><td style="text-align:center">BTC.TOP</td><td style="text-align:center">197.27</td><td style="text-align:center">715.72</td></tr></tbody></table><p>其中的重量是指的实际存储的大小，这个值和交易协议有关，其实可以忽略。非常幸运的是，<strong>这几个区块放佛是专门为讲解这一节而出现的</strong>，这可能是天意吧</p><p>另外插一句，你会发现<strong>平均区块建立间隔时间</strong>，的确和10分钟这个设计值差距很大吧</p><h3 id="区块容量"><a href="#区块容量" class="headerlink" title="区块容量"></a>区块容量</h3><p>比特币从被创建时，或者说源代码中规定了，区块容量是1M。最初设计成1M的原因一方面，<strong>防止DOS攻击</strong>。另一方面，当年中本聪在创建区块链的时候的容量是32M，但是他通过一个说明为”Clear up“这样毫不起眼的Commit把区块容量改成了1M，为<strong>防止区块链体积增长过快</strong>，为区块容量这个问题添加了些神秘色彩。好吧，我承认，中本聪就已经非常具有神秘色彩了，是在神秘色彩上添上了些故事</p><p>通过上表我们知道，1M的容量意味着比特币最大的处理交易数量在约2400（486882区块1034.39的大小很接近了），在给出<a href="http://charts.woobull.com/bitcoin-transactions-per-second/" target="_blank" rel="external">一张时间和每秒交易数量的关系图表</a>(交互表格点击链接)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/BitcoinTraPS.png" alt="每秒比特币交易数量" title="">                </div>                <div class="image-caption">每秒比特币交易数量</div>            </figure><blockquote><p>这是一张对数图，纵坐标是每秒交易数量，横坐标是时间。其中，蓝色圆圈的大小代表的是比特币内存池（mempool）的大小（交易在等待矿工处理之前都会暂时存在这里）。</p></blockquote><p>一句话总结，这是一个拥堵的网络，已经重负不堪。</p><p>再来看一张<a href="http://charts.woobull.com/bitcoin-blocksize-fees/" target="_blank" rel="external">比特币交易费和区块使用率之间的关系图</a>(交互表格可以点击链接)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/FeesVsBlocksize.png" alt="Bitcoin Fees VS BlockSize" title="">                </div>                <div class="image-caption">Bitcoin Fees VS BlockSize</div>            </figure><blockquote><p>蓝色的圈大小是Mempool的大小。横坐标是区块容量的使用情况，纵坐标是每一个区块的可以得到的交易费用。</p></blockquote><p>手续费随区块使用率开始增长，甚至出现了4BTC一个区块2400笔交易的情况，意味着挖到这个区块的人通过交易费得到的汇报接近了本身建立区块的回报</p><p>有一个结论是，扩容后，因为每一个区块的交易承载量增加，矿工的交易费收入肯定会减少。因为，通过上表可以发现，只有当区块使用程度接近95%时候，交易费才有明显的增长</p><p>再看一张<a href="http://charts.woobull.com/bitcoin-blocksize-confirm-time/" target="_blank" rel="external">用户执行交易需要等待的时长和区块使用比例间关系的图表</a>(交互图表点击链接)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/TimeVSBlocksize.png" alt="Bitcoin Median Confirmation Time VS Bloacksize" title="">                </div>                <div class="image-caption">Bitcoin Median Confirmation Time VS Bloacksize</div>            </figure><blockquote><p>蓝色的圈大小是Mempool的大小。横坐标是区块容量的使用情况，纵坐标是用户平均需要等待的时间，单位是分钟。</p></blockquote><p>通过上面三张表我们可以知道，矿工的计算力是整个区块链信用的基石（记住贪婪=信任），所以对矿工的激励不能少，而对于用户来说，当然希望自己的交易越快速完成越好。</p><p>对于矿工来说，区块使用率超过95%是一个很好的信号，那意味着我可以拿到更多的奖励。奖励太低，在区块建立奖励越来越少的情况下，安全性（信任）就慢慢的得不到保障。这么说来，<strong>这也就变成了一个Trade-off博弈过程</strong></p><p>分析下来，<strong>类似门罗币（menero）实现的根据网络负载来动态调整区块容量的设计似乎很合理</strong></p><h3 id="比特币扩容之争"><a href="#比特币扩容之争" class="headerlink" title="比特币扩容之争"></a>比特币扩容之争</h3><p>这是一场复杂的博弈斗争，使用隔离见证把增长区块容量，并出现了比特币现金一个新的币种。</p><p>如果想要了解这里面的很多技术，英文是必须过硬的，因为比特币代码开源，可以随意fork，只要英文功底过硬，阅读白皮书，文档等，这些不同技术的处理方法都是能够学到的</p><h2 id="比特币的一笔交易过程中到底发生了什么"><a href="#比特币的一笔交易过程中到底发生了什么" class="headerlink" title="比特币的一笔交易过程中到底发生了什么"></a>比特币的一笔交易过程中到底发生了什么</h2><p>我们可以确认的是，每一笔都将记录在大账本中，那么我们需要研究的内容，就是区块中交易内容内的具体数据结构</p><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><p>每一个交易块包含的内容如下表所示</p><table><thead><tr><th style="text-align:center">大小</th><th style="text-align:center">字段</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">4 bytes</td><td style="text-align:center">版本</td><td style="text-align:center">明确这笔交易参照的规则</td></tr><tr><td style="text-align:center">1 - 9 bytes</td><td style="text-align:center">输入数量</td><td style="text-align:center">输入值的数量</td></tr><tr><td style="text-align:center">不定</td><td style="text-align:center">输入</td><td style="text-align:center"><strong>一个或多个交易输入</strong></td></tr><tr><td style="text-align:center">1 - 9 bytes</td><td style="text-align:center">输出数量</td><td style="text-align:center">输出值的数量</td></tr><tr><td style="text-align:center">不定</td><td style="text-align:center">输出</td><td style="text-align:center"><strong>一个或多个交易输出</strong></td></tr><tr><td style="text-align:center">4 bytes</td><td style="text-align:center">时钟时间</td><td style="text-align:center">UNIX时间戳或区块号</td></tr></tbody></table><p>最后这个值是解锁时间，定义了能被加到区块链里的最早交易时间。大多是时候射程0，表示立马执行。</p><p>一笔比特币交易是一个含有<strong>输入值</strong>和<strong>输出值</strong>的<strong>数据结构</strong>。该数据结构<strong>包含了将一笔资金从初始点（输入值）转移至目标地址（输出值）的代码信息</strong>。比特币交易的输入值和输出值与账号或者身份信息无关。可以把它理解为一种<strong>被特定秘密信息锁定的一定数量的比特币</strong>。只有拥<strong>有者或者知道这个秘密信息的人</strong>可以解锁</p><h3 id="交易的输入和输出"><a href="#交易的输入和输出" class="headerlink" title="交易的输入和输出"></a>交易的输入和输出</h3><p>比特币交易的基本单位是<strong>未经使用的一个交易输出</strong>，简称UTXO（unspent transaction outputs）</p><p>可以把UTXO类比为我们使用的<strong>人民币1，5，10，20，50，100的面值</strong>，对于UTXO来说，它的面值可以是一”聪“的认识倍数（1BTC等于一亿聪）<strong>但是</strong>这个有着任意面值的”人民币“不能随意打开，还被加上一道类似<strong>红包支付口令的密码</strong>，只有拥有这个密码的人才可以使用这个UTXO，UTXO包含，币值+一段代码（锁，只有有钥匙的人才能打开）</p><p>被交易消耗的UTXO被称为交易输入，由交易创建的UTXO被称为交易输出</p><h4 id="交易输出"><a href="#交易输出" class="headerlink" title="交易输出"></a>交易输出</h4><p>也就是说，<strong>不同种类的面值由交易输出来提供的</strong>，你可以想象你需要购买一个3.1BTC的物品，你并不能从你的钱包中找到几个UTXO来得到3.1BTC，但是你刚好拥有一个4BTC的UTXO，你使用这个UTXO作为付款，那么你需要自己<strong>手动构建一个0.9的UTXO返还给你自己</strong>。</p><p>一个交易输出包含两个部分</p><ul><li>一定量的比特币。被命名为“聪”（satoshis）</li><li>一个<strong>锁定脚本</strong>。给这个UTXO上锁，保证只有<strong>收款人地址</strong>的私钥才可以打开</li></ul><h4 id="交易输入"><a href="#交易输入" class="headerlink" title="交易输入"></a>交易输入</h4><p>比如你需要支付0.015BTC，钱包会寻找一个0.01BTC和0.005BTC的UTXO来组成这一笔交易。其中还会包含一个解锁脚本，这是一个签名，可以类比成支付宝红包密码的口令</p><h4 id="交易费"><a href="#交易费" class="headerlink" title="交易费"></a>交易费</h4><p>交易费 = 求和（所有输入） - 求和（所有输出）</p><p>这里有一个比较有意思的地方，就是因为找零的输出UTXO是交易的发起这自己构建的，如果很不幸，你忘记了自己构建找零的UTXO，那么这些多余的BTC就会变成矿工的劳务费</p><p>例如，我需要和小明进行交易，需要购买一个商品，花费<code>0.8BTC</code>，为了确保这笔交易能被更快的处理（添加到大账本上），我要在其中添加一笔交易费，假设<code>0.01BTC</code>（忽略人傻钱多），那就意味着这笔交易会需要我从钱包中找到几个UTXO能组成<code>0.81BTC</code>。但如果我的钱包内找不出这样的UTXO，只有一个<code>1BTC</code>的UTXO可用，那么我就需要构建一个<code>0.19BTC</code>的UTXO作为找零回到自己的钱包</p><p><strong>交易费只和交易字段使用的字节大小有关，与参与交易的比特币币值无关</strong>。UTXO是有尺寸的，比如某人想支付一笔很大的BTC交易，但是他的钱包中有很多小尺寸的UTXO，如果加入了很多个UTXO，就以为这他的交易会变复杂且尺寸大。</p><h4 id="解锁和锁定脚本"><a href="#解锁和锁定脚本" class="headerlink" title="解锁和锁定脚本"></a>解锁和锁定脚本</h4><p>在实际实现的时候，这个“支付宝红包口令”被称为脚本，是一种基于逆波兰表示法的基于堆栈的执行语言。具体细节感兴趣的读者可以去比特币的Github研究代码。关于脚本有很多细节上的定义和实现方法，这里限于篇幅不展开描述了</p><h3 id="矿工费和优先级"><a href="#矿工费和优先级" class="headerlink" title="矿工费和优先级"></a>矿工费和优先级</h3><p>我们知道，<strong>每一笔交易都是广播到区块链上，由矿工决定是不是加入到新区块上的</strong>。那么这里就会涉及到一个问题，谁的交易的优先级更高，是先来后到？还是谁给前多谁就能加入到新区块呢。</p><p>在区块容量一节中，有一张图表直观的展示了现在网络中一笔交易的等待时间，其中最长的，也就是30分钟，如果你不是一个超级急性子，很多时候还是可以接受的（毕竟跨国转账1-2个工作日的）</p><p>优先级 = 输入值块龄 * 输出值块龄 / 交易总长度</p><p>一个交易想成为“较高优先级”，需满足条件：优先值大于57600000，相当于一个BTC，年龄为1天，交易的大小为250字节</p><p>区块中钱50KB的字节是保留给“较高优先级”的，其实这一机制也保证了一笔交易不会等待时间无现长</p><h3 id="创币交易-Coinbase"><a href="#创币交易-Coinbase" class="headerlink" title="创币交易 - Coinbase"></a>创币交易 - Coinbase</h3><p>每一个新区块的简历，都会有新的比特币作为奖励被产生，这个交易是一个特殊交易，被称为<strong>创币交易（Coinbase奖励）</strong></p><p>创币交易中不存在解锁脚本（也叫ScriptSig字段），被Coinbase的数据取代，长度最小2字节，最大100字节，除了开始的几个自己以外，矿工可以任意使用Coinbase的其他部分。比如创世区块中，Coinbase的输入中的字段是：The Times 03/Jan/2009 Chancellor on brink of second bailout for banks，是泰晤士日报当天的头版文章标题：财政大臣将再次对银行施以援手。</p><h2 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h2><p><strong>每个区块中的所有交易，都是用Merkle树来表示的</strong>。换句话说，交易的存储数据结构是，Merkle树</p><h4 id="什么是Merkle树"><a href="#什么是Merkle树" class="headerlink" title="什么是Merkle树"></a>什么是Merkle树</h4><p>Merkle树是一种哈希二叉树，它还可以用来进行<strong>快速查找和检验大规模数据完整性</strong>。对于比特币网络来说，使用Merkle树来存储交易信息的目的是为了<strong>高效的查找和校验某笔交易的信息是否存在</strong></p><p>当N个数据元素经过加密（使用两次SHA256算法，也称double-SHA256），<strong>至多</strong>计算 $2log_2(N)$ 次就能<strong>检查出任意某元素是否在树中</strong></p><h4 id="构造Merkle树"><a href="#构造Merkle树" class="headerlink" title="构造Merkle树"></a>构造Merkle树</h4><p>假设我们有A B C D四笔交易字段，首先需要把这四个数据Hash化。然后把这些哈细化的<strong>数据通过串联相邻叶子节点</strong>的哈希值然后哈希化。基本过程如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/24/一文弄懂区块链-以比特币为例/MerkleTree.png" alt="Merkle树的构造过程" title="">                </div>                <div class="image-caption">Merkle树的构造过程</div>            </figure><h4 id="Merkle树的效率"><a href="#Merkle树的效率" class="headerlink" title="Merkle树的效率"></a>Merkle树的效率</h4><p>下表显示了证明区块中存在某笔交易所需转化为Merkle路径的数据量</p><table><thead><tr><th style="text-align:center">交易数量</th><th style="text-align:center">区块的近似大小</th><th style="text-align:center">路径大小（哈希数量）</th><th style="text-align:center">路径大小（字节）</th></tr></thead><tbody><tr><td style="text-align:center">16</td><td style="text-align:center">4KB</td><td style="text-align:center">4个哈希</td><td style="text-align:center">128 bytes</td></tr><tr><td style="text-align:center">512</td><td style="text-align:center">128KB</td><td style="text-align:center">9个哈希</td><td style="text-align:center">288 bytes</td></tr><tr><td style="text-align:center">2048</td><td style="text-align:center">512KB</td><td style="text-align:center">11个哈希</td><td style="text-align:center">352 bytes</td></tr><tr><td style="text-align:center">65535</td><td style="text-align:center">16MB</td><td style="text-align:center">16个哈希</td><td style="text-align:center">512 bytes</td></tr></tbody></table><p>可以发现，即使区块容量达到16MB规模，为证明交易存在的Merkle路径长度增长也极其缓慢（幂指数增长取对数变为线性增长）</p><h4 id="Merkle应用-简单支付验证节点（SPV）"><a href="#Merkle应用-简单支付验证节点（SPV）" class="headerlink" title="Merkle应用 - 简单支付验证节点（SPV）"></a>Merkle应用 - 简单支付验证节点（SPV）</h4><p>我们知道，每当一笔新的交易产生的时候，我们必须<strong>验证这笔交易是否真的存在</strong>，在SPV节点中，不保存区块链，仅仅保存区块头。<strong>使用认证路径或者Merkle路径来验证交易是否存在于区块中</strong></p><p>例如，一个SPV节点需要处理一笔支付，它<strong>需要验证这笔交易在某个区块中是否存在</strong>，才能决定是不是把这笔交易添加到这个区块中，那么它只需要接收少于1KB大小的，<strong>有关区块头和Merkle路径的信息</strong>，比接收完整区块（大约1MB）大小少了1千倍。简单来说，可以想象，Merkle树类似<strong>一个数组</strong>（这也是哈希表的最简单表示），<strong>下标是区块字段</strong>，下标对应<strong>数组存储的内容是这笔交易是否存在的值（True or False）</strong></p><h1 id="各类竞争币"><a href="#各类竞争币" class="headerlink" title="各类竞争币"></a>各类竞争币</h1><p>所谓竞争币当然是利用区块链技术为即使，仿照比特币的基本协议架构进行的创新后的新币种，或者是新的区块链实现模式。这篇文章围绕什么是区块链展开，这部分的内容请移步<a href="https://charlesliuyx.github.io/2017/09/25/%E8%AF%84%E4%BC%B0%E7%AB%9E%E4%BA%89%E5%B8%81%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/">如何评估竞争币的价值与智能合约</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感谢您看到这里，写这篇文章的目的一方面也是回答<strong>区块链（比特币）到底是什么</strong>这个困扰了自己很久的问题，另一方面，也是因为最近区块链技术非常火，需要<strong>一些接地气的科普文</strong></p><p>比如最近最新的消息称一家保险公司，使用区块链技术来赔偿航班晚点2小时，基于以太坊智能合约第一款落地应用。</p><p>如果你已经对区块链的实现原理有了初步的认知，想法都是美好的（当然，最近区块链方面的突破性技术一直在被发现，比如侧链，闪电网络等等，太多的新概念，新名词，新技术，对此，也只能不断学习）。</p><p>但你只需牢记，贪婪=信任，以太坊也是利用以太币这个媒介来实现了合约价值，中本聪用人内核的贪婪来给陌生人之间加上了信任的纽带，这个代价是永远不会变的。换句话说，如何抵抗共识攻击和安全漏洞是一个永远不会消失的议题。</p><p>一句话来说，万变不离其宗，道生一，一生二，二生三，三生万物。中本聪给了道，是个妙人，但是<strong>万物</strong>依旧有无穷可能。<strong>信任作为一个人类社会一直以来的重要问题（痛点）</strong>，为了解决它，出现了<strong>权威机构进行信任背书（中心化）</strong>。建立信任，一定要付出代价，天底下没有免费的午餐，最终这些技术都会回归于一个投入产出的博弈过程（Trade-off），梳理主干，抓住要点，才能游刃有余！</p><p>那么如何才能梳理主干，抓住要点，提升学习能力呢？见谅加一个软广告</p><p>幕布是一款笔记本软件，博主参与了部分研发工作，如果你喜爱沉浸式层次化输入，并喜欢思维导图，还喜爱记录总结各种书籍或文章，幕布完美切合这三类人群的需求：一键生成思维导图，极简输入界面，快捷键操作！Organize your brain by mubu</p><p><a href="https://mubu.com/inv/121749" target="_blank" rel="external">点我</a>一键微信注册，一个月9块钱，良心商家，<a href="https://www.zhihu.com/question/20772002/answer/192382928" target="_blank" rel="external">这个</a>是一篇我自己写的有关幕布的介绍文章</p><p>以上，鞠躬！</p><p>除了<a href="https://www.zhihu.com/question/22076666" target="_blank" rel="external">江卓尔 知乎回答</a>等优秀的知乎答主的回答，附参考文献出处：<br>【1】文章中引用多个Gif的出处：<a href="https://www.bilibili.com/video/av12465079/" target="_blank" rel="external">比特币原理-3B1B</a>，这也是让我真正弄懂比特币的一个视频，不得不说，外国人在让门外汉入行这件事上，领先了很多<br>【2】一本入门教材。包含代码和实现，以及很多数据结构，具体实现方式的细节，如果想成为加密货币（区块链）开发者，这本书5星推荐：<a href="http://8btc.com/topic-mastering-bitcoin.html" target="_blank" rel="external">精通比特币</a><br>【3】宋老师的<a href="http://v.youku.com/v_show/id_XMjc3MDU4MDY2OA==.html?spm=a2h1n.8261147.reload_201705.1~3!2~5~A" target="_blank" rel="external">鸿观125期</a> （需要优酷会员）<br>【4】只能膜拜之的创世区块作者的论文：<a href="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system" target="_blank" rel="external">比特币白皮书</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】25min - 35min&lt;br&gt;【内容简介】此文潜在面向群体是对区块链或比特币的运行原理完全不了解的人。所以会从&lt;strong&gt;用户需求&lt;/strong&gt;的角度出发，&lt;strong&gt;一步一步发明区块链&lt;/strong&gt;，在此之后的内容会涉及一些思考和技术上的原理延伸，可以选择性阅读&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="BlockChain" scheme="https://charlesliuyx.github.io/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="https://charlesliuyx.github.io/tags/BlockChain/"/>
    
      <category term="BTCoin" scheme="https://charlesliuyx.github.io/tags/BTCoin/"/>
    
  </entry>
  
  <entry>
    <title>【直观详解】拉格朗日乘法和KKT条件</title>
    <link href="https://charlesliuyx.github.io/2017/09/20/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%B3%95%E5%92%8CKKT%E6%9D%A1%E4%BB%B6/"/>
    <id>https://charlesliuyx.github.io/2017/09/20/拉格朗日乘法和KKT条件/</id>
    <published>2017-09-20T17:49:49.000Z</published>
    <updated>2017-09-21T05:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】8min - 10mun<br>【内容简介】直观的解读了什么是拉格朗日乘子法，以及如何求解拉格朗日方程，并且给出几个直观的例子，针对不等式约束解读了KKT条件的必要条件和充分条件<br><a id="more"></a></p><h1 id="What-amp-Why"><a href="#What-amp-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h1><p>拉格朗日乘法（Lagrange multiplier）是一种在<strong>最优化的问题中</strong>寻找多元函数在其变量<strong>受到一个或多个条件的相等约束</strong>时的<strong>求局部极值的方法</strong>。这种方法可以将一个有 n 个变量和 k 个约束条件的最优化问题转换为一个<strong>解有 n+k 个变量的方程组的解的问题</strong></p><p>考虑一个最优化问题</p>$$\operatorname*{max}_{x,y} f(x,y) \qquad s.t.\;\; g(x,y)=c$$<p>为了求 $x$ 和 $y$ ，引入一个新的变量 $\lambda$ 称为<strong>拉格朗日乘数</strong>，再引入朗格朗日函数的极值<br>$$<br>\mathcal{L}(x,y,\lambda)=f(x,y)-\lambda \cdot \bigl( g(x,y) - c\bigl) \tag 1<br>$$<br><img src="//charlesliuyx.github.io/2017/09/20/拉格朗日乘法和KKT条件/LagrangeMultiplier.png" width="500px"></p><blockquote><p>红线表示 $g(x,y) = c$ ，蓝线是 $f(x,y)$ 的<strong>等高线</strong>，所有箭头表示梯度下降最快的方向。图中<strong>红线与等高线相切</strong>的位置就是待求的极大值</p></blockquote><h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>那么如何求这个极值点呢？</p><h2 id="单约束"><a href="#单约束" class="headerlink" title="单约束"></a>单约束</h2><p>对(1)式直接求微分，并令其为零，计算出<strong>鞍点</strong></p>$$\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) = 0$$有三个未知数，所以需要3个方程。求 $\lambda$ 的偏微分有 $\nabla_{\lambda} \mathcal{L}(x,y,\lambda) = 0 \implies g(x,y)=0$，则总结得$$\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) = 0 \iff \begin{cases}\nabla_{x,y} f(x,y) = \lambda \nabla_{x,y} g(x,y) \\g(x,y)=0\end{cases}$$<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>设一个具体的例子，我们需要求下列问题<br>$$\operatorname*{max}_{x,y} f(x,y) = x^2y \qquad s.t.\;\; g(x,y): x^2+y^2-3=0$$<br><img src="//charlesliuyx.github.io/2017/09/20/拉格朗日乘法和KKT条件/Lagrange_simple_1.png" width="500px"><br>只有<strong>一个约束</strong>，使用<strong>一个乘子</strong>，设为 $\lambda$，列出<strong>拉格朗日函数</strong><br>$$\mathcal{L}(x,y,\lambda)=f(x,y)-\lambda \cdot \bigl( g(x,y) - c\bigl) = x^2y + \lambda(x^2+y^2-3)$$<br>接下来求解上式，分别对<strong>三个待求量偏微分</strong><br>$$\begin{align}\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) & = \left( \frac{\partial \mathcal{L}}{\partial x},\frac{\partial \mathcal{L}}{\partial y},\frac{\partial \mathcal{L}}{\partial \lambda}\right)\\& = (2xy + 2\lambda x, x^2 + 2\lambda y, x^2 + y^2 - 3)\end{align}$$<br>令<strong>偏微分分别等于0</strong>，得到<br>$$\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) = 0 \iff \begin{cases}2xy+2\lambda x = 0 \\x^2 + 2\lambda y = 0 \\x^2 + y^2 - 3 = 0\end{cases}\iff\begin{cases}x(y + \lambda) = 0  & (i)\\x^2 = -2\lambda y  & (ii)\\x^2 +y^2 = 3 & (iii)\end{cases}$$<br>根据上式，我们可以解得 $\mathcal{L}$:<br>$$(\pm \sqrt{2},1,-1 ); (\pm \sqrt{2},-1,1 );(0,\pm \sqrt{3},0)$$<br>根据几个不同的解带入 $f(x,y)$ 得到，2，-2，0，也就是我们需要的最大值，最小值，对应的直观图像解释如下图所示（<strong>非常直观的展现约束和等高线的含义</strong>）</p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>关于拉格朗日乘子法的应用，有一个十分著名的：求<strong>离散概率分布  $p_1,p_2,\cdots,p_n$  的最大<a href="https://charlesliuyx.github.io/2017/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E6%81%AF%E7%86%B5%E3%80%81%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8C%E7%9B%B8%E5%AF%B9%E7%86%B5/">信息熵</a></strong><br>$$f(p1,p2,\cdots,p_n) = - \sum_{j=1}^n p_j log_2{p_j} \\s.t. \quad g(p1,p2,\cdots,p_n) = \sum_{k=1}^n p_k = 1 \text{（概率和为1）}$$</p><p>单约束问题，引入一个乘子 $\lambda$ ，对于 $k \in [1,n]$ ，要求<br>$$\frac{\partial}{\partial p_k} (f + \lambda(g - 1)) = 0$$将 $f$ 和 $g$ 带入有$$\frac{\partial}{\partial p_k} \left(  -\sum_{k=1}^np_klog_2{p_k} + \lambda (\sum_{k=1}^n p_k - 1)\right) = 0$$计算这 n 个等式的偏微分，我们可以得到：$$-\left( \frac{1}{\ln(2)} + log_2p_k \right) + \lambda = 0$$</p><p>这说明所有的 $p_i$ 都相等，所以得到 $p_k = \frac{1}{n}$ </p><p>我们可以得到一个结论是：<strong>均匀分布的信息熵是最大的</strong></p><h2 id="多约束"><a href="#多约束" class="headerlink" title="多约束"></a>多约束</h2><p>既然可以解决单约束，继续思考一下多约束情况的直观表现，假设我们的约束是两条线，如下图所示</p><p><img src="//charlesliuyx.github.io/2017/09/20/拉格朗日乘法和KKT条件/lgm_parab.png" width="450px"></p><p>和单约束的解决方法类似，我们画出等高线图，目的就是<strong>在约束线上找到一个点可以和等高线相切，所得的值实在约束范围内的最大值或者最小值</strong>，直观表示如下图</p><p><img src="//charlesliuyx.github.io/2017/09/20/拉格朗日乘法和KKT条件/lgm_levelsets.png" width="450px"></p><p>解算方法是讲单约束的扩展到多约束的情况，较为类似，可举一反三</p><h1 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h1><p>已经解决的在<strong>等式约束条件下</strong>的求函数极值的问题，那<strong>不等式约束条件</strong>下，应该如何解决呢？</p><p>这就需要引出<strong>KKT条件</strong>（Karush-Kuhn-Tucker Conditions），它是在满足一些有规则的条件下，一个<strong>非线性规划问题能有最优化解法</strong>的一个必<strong>要和充分条件</strong></p><p>考虑以下非线性最优化问题，含有 $m$ 个不等式约束，$l$ 个等式约束<br>$$<br>\operatorname*{min}_{x}f(x) \qquad s.t. \; g_i(x) \leqslant 0,\; h_j(x) =0<br>$$</p><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>假设 $f,g_i,h_j$ 三个函数为<strong>实数集映射</strong>，再者，他们都在 $x^<em>$ 这点<strong>连续可微</strong>，如果 $x^</em>$  是一个<strong>局部极值</strong>，那么<strong>将会存在</strong>一组<strong>称为乘子</strong>的常数 $\lambda \geqslant 0,\mu_i \geqslant0, \nu_j$  令<br>$$\lambda + \sum_{i=1}^m \mu_i + \sum_{j=1}^l |\nu_i| \gt 0, \\\lambda \nabla f(x^*) + \sum_{i=1}^m \mu_i  \nabla g_i(x^*) + \sum_{j=1}^l \nu_i  \nabla h_j(x^*) = 0, \\\mu_i  g_i(x^*) =0 \; \text{for all} \; i=1,\ldots,m$$</p><p>这里有一些<strong>正则性条件或约束规范</strong>能保证解法不是退化的（比如$\lambda$为0），<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E7%BE%85%E9%9C%80%EF%BC%8D%E5%BA%AB%E6%81%A9%EF%BC%8D%E5%A1%94%E5%85%8B%E6%A2%9D%E4%BB%B6" target="_blank" rel="external">详见</a></p><h2 id="充分条件"><a href="#充分条件" class="headerlink" title="充分条件"></a>充分条件</h2><p>假设 $f,g_i$ 为<strong>凸函数</strong>，$h_j$ 函数是<strong>仿射函数</strong>（平移变换），假设有一个可行点 $x^*$，如果有常数 $\mu_i \geqslant 0$ 及 $\nu_j$ 满足<br>$$\nabla f(x^*) + \sum_{i=1}^m \mu_i  \nabla g_i(x^*) + \sum_{j=1}^l \nu_i  \nabla h_j(x^*) = 0 \\\mu_i  g_i(x^*) =0 \; \text{for all} \; i=1,\ldots,m$$</p><p>那么 $x^*$ 就是<strong>全局极小值</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，拉格朗日乘子法是<strong>一个工具（手段或方法）</strong>，来<strong>解决在有约束情况的求函数极值的问题</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】8min - 10mun&lt;br&gt;【内容简介】直观的解读了什么是拉格朗日乘子法，以及如何求解拉格朗日方程，并且给出几个直观的例子，针对不等式约束解读了KKT条件的必要条件和充分条件&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Theory" scheme="https://charlesliuyx.github.io/tags/Theory/"/>
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>【直观详解】支持向量机SVM</title>
    <link href="https://charlesliuyx.github.io/2017/09/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://charlesliuyx.github.io/2017/09/19/支持向量机SVM学习笔记/</id>
    <published>2017-09-20T01:23:39.000Z</published>
    <updated>2017-09-21T23:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】13min - 19min<br>【内容简介】详解解读什么是支持向量机，如何解支持向量以及涉及的拉普拉斯乘子法，还有核方法的解读</p><a id="more"></a><h1 id="什么是支持向量机-SVM"><a href="#什么是支持向量机-SVM" class="headerlink" title="什么是支持向量机-SVM"></a>什么是支持向量机-SVM</h1><p>支持向量机-SVM(Support Vector Machine)从本质来说是一种：<strong>用一条线（方程）分类两种事物</strong></p><p>SVM的任务是找到这条分界线<strong>使得它到两边的<code>margin</code>都最大</strong>，<font color="FF00000">注意，这里的横坐标是 $x_1$ 纵坐标为 $x_2$</font>，如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/19/支持向量机SVM学习笔记/SVM-margin.jpg" alt="margin" title="">                </div>                <div class="image-caption">margin</div>            </figure><p>有了直观的感知，在定义这一节在做一些深入的思考，分解名词（Support Vector Machine）并尝试解释：</p><ul><li><strong>Machine</strong> - Classification Machine 说明它的本质是一个<strong>分类器</strong></li><li><strong>Support Vector</strong> - 如上图所示，在<code>Maximum Margin</code>上的<strong>这些点</strong>就是<strong>支持向量</strong>，具体说即最终分类器表达式中<strong>只含有这些支持向量</strong>的信息，而与其他数据点无关。在下面的公式中，只有<strong>支持向量的系数</strong> $\alpha_i$ 不等于0。说人话，<strong>上图中两个红色的点，一个蓝色的点，合起来就是支持向量</strong>$$\mathbf w \cdot \varphi (\mathbf x) = \sum_i \lambda_i y_i k(\mathbf x_i,\mathbf x)$$</li></ul><blockquote><p>公式中每一个符号的含义在后文有说明</p></blockquote><h1 id="如何求解支持向量机"><a href="#如何求解支持向量机" class="headerlink" title="如何求解支持向量机"></a>如何求解支持向量机</h1><p>对于我们需要求解的这个超平面（直线）来说，我们知道</p><ul><li>它离<strong>两边一样远</strong>（待分类的两个部分的样本点）</li><li><strong>最近的距离</strong>就是到<strong>支持向量中的点</strong>的距离</li></ul><p>根据这两点，抽象SVM的直接表达（Directly Representation）</p><blockquote><p>注：$arg \operatorname*{max}_{x} f(x)$ 表示当 $f(x)$ <strong>取最大值时，x的取值</strong></p></blockquote>$$arg \operatorname*{max}_{boundary} margin(boundary) \\ \text{所有正确归类的两类到boundary的距离} \ge margin \tag{1}$$<p>其实这个公式是一点也不抽象，需要更进一步的用符号来表达。</p><p>我们知道<strong>在准确描述世界运行的规律这件事上，数学比文字要准确并且无歧义的多，文字（例子）直观啰嗦，数学（公式）准确简介</strong></p><h2 id="硬间隔"><a href="#硬间隔" class="headerlink" title="硬间隔"></a>硬间隔</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/19/支持向量机SVM学习笔记/SVM-Intuitive.jpg" alt="SVM支持向量机" title="">                </div>                <div class="image-caption">SVM支持向量机</div>            </figure><blockquote><p>注：公式中加粗或者带有向量箭头的都<strong>表达一个向量</strong></p></blockquote><ul><li>假设这些数据<strong>线性可分</strong>，也可称为<strong>硬间隔</strong>（Hard Margin）</li><li>首先定义超平面：$\mathbf w^T \vec x_i + b = 0$，接下来为了方便，设  $\vec x = (x_1,x_2)$  即一条直线</li><li>任意点 $\vec x_i$ 到该直线的距离为 $\frac{1}{\lVert \mathbf w \lVert} (\mathbf w^T \vec x_i + b)$</li><li>对于空间内所有训练点的坐<strong>标记为</strong> $(\vec x_i,y_i)$，其中 $y_i$ = 1 or -1， 表示点 $\vec x_i$ <strong>所属的类</strong></li><li>如果这些训练数据是线性可分的，选出两条直线（上图中的虚线），使得他们的距离尽可能的大，这两条直线的中央就是<strong>待求的超平面</strong>（直线）</li><li><p>为了表达直观，我们定义这两个超平面（直线）分别为 $\mathbf w^T \vec x_i + b = 1$ 和 $\mathbf w^T \vec x_i + b = -1$，两个超平面（直线）之间的距离为 $\gamma = \frac{2}{\lVert \mathbf w \lVert}$</p><blockquote><p>注：选择<code>1</code>的好处是，<code>w</code> 和<code>b</code>进行尺缩变换（<code>kw</code>和<code>kb</code>）不改变距离，方便计算</p></blockquote></li><li><p>为了使得所有<strong>样本数据都在间隔区（两条虚线）以外</strong>，我们需要保证对于所有的 $i$ 满足下列的条件</p><ul><li>$\mathbf w^T \vec x_i + b \geqslant 1$ 若 $y_i = 1$</li><li>$\mathbf w^T \vec x_i + b \leqslant -1$ 若 $y_i = -1$</li></ul></li><li>上述两个条件可以写作  $y_i(\mathbf w^T \vec x_i + b) \geqslant 1, \;\text{for all 1}\; 1\leqslant i \leqslant n$  这里的<code>n</code>指样本点的数量</li><li><p>上面的表达（Directly Representation）可以被写成</p>$$arg \operatorname*{max}_{\mathbf w,b} \left\{ {\frac{1}{\lVert \mathbf w \lVert} \operatorname*{min}_{n} [y_i(\mathbf w^T\vec x_i}+b)]\right\} \tag{2}$$</li><li><p>最终目的是<strong>找到具有“最大间隔”（Maximum Margin）的划分超平面（直线），找到参数 $\mathbf w$ 和 $b$ 使得 $\gamma$ 最大</strong></p></li><li>则可以对(2)式进行形式变换，得到 canonical representation$$arg \operatorname*{max}_{\mathbf w,b} \frac{2}{\lVert \mathbf w \lVert} \implies  arg \operatorname*{min}_{\mathbf w,b} \frac{1}{2}\lVert \mathbf w \lVert ^2 \\ s.t.\; y_i(\mathbf w^T\vec x_i+b) \geqslant1,\;i = 1,2,\ldots,m  \tag{3}$$</li></ul><blockquote><p>注：<code>s.t.</code> ：subject to 表示约束条件，表达的意思等价于：为了使得所有<strong>样本数据都在间隔区（两条虚线）以外</strong></p></blockquote><p>为了解(3)式，需要用到<strong>拉格朗日乘子法</strong>（Method of lagrange multiplier），它是用来求解在约束条件目标函数的极值的，<a href="https://charlesliuyx.github.io/2017/09/20/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%B3%95%E5%92%8CKKT%E6%9D%A1%E4%BB%B6/">详细直观详解</a></p><blockquote><p>注：以下解算过程希望完全看懂强烈建议理解阅读<a href="https://charlesliuyx.github.io/2017/09/20/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%B3%95%E5%92%8CKKT%E6%9D%A1%E4%BB%B6/">详细直观详解</a>，很多地方推导过程只写必要过程及结论</p></blockquote><p>根据约束的形式，我们引入<code>m</code>个拉格朗日乗法子，记为  $\boldsymbol \lambda = (\lambda_1,\ldots,\lambda_m)^T$ ，原因是，有<code>m</code>个约束，所以需要<code>m</code>个拉格朗日乗法子。可以得出拉格朗日方程如下：<br>$$\mathcal{L}(\mathbf w,b,\boldsymbol \lambda) = \frac{1}{2}\lVert \mathbf w \lVert ^2  - \sum_{i=1}^m \lambda_i \{  y_i(\mathbf w^T\vec x_i+b) -1 \} \tag{4}$$</p><p>解这个拉格朗日方程，对 $\mathbf w$ 和 $b$ 求偏导数，可以得到以下两个条件<br>$$\mathbf w = \sum_{i=1}^m \lambda_i y_i \vec x_i \\0 = \sum_{i=1}^m \lambda_i y_i$$</p><p>将这两个条件带回公式(4)，可以得到<strong>对偶形式（dual representaiton）</strong>，我们的目的也变为最大化 $\mathcal{L}(\boldsymbol \lambda)$，表达式如下<br>$$arg \operatorname*{max}_{\boldsymbol \lambda}\mathcal{L}(\boldsymbol \lambda)  = \sum_{i=1}^m \lambda_i - \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m \lambda_i \lambda_j \vec x_i \vec x_j \mathbf x_i^T \mathbf x_j \\s.t. \qquad \lambda_i \geqslant 0, \forall i\;;\quad \sum_{i=1}^m \lambda_i y_i = 0 \tag{5}$$</p><p>以上表达式可以通过<strong>二次规划</strong>算法解出 $\boldsymbol \lambda$ 后，带回，求出$\mathbf w$ 和 $b$，即可得到模型<br>$$f(\mathbf x) = \mathbf w^T\mathbf x + b = \sum_{i=1}^m \lambda_i y_i \mathbf x_i^T \mathbf x + b \tag{6}$$</p><p>补充一些关于<strong>二次规划</strong>算法的相关，(3)式的约束是一个不等式约束，所以我们可以使用KKT条件得到三个条件：<br>$$\lambda_i \geqslant0 ;\quad y_i f(\mathbf x_i)-1 \geqslant0; \quad \lambda_i\{ y_i f(\mathbf x_i)-1 \}=0$$</p><p>使用这些条件，可以构建高效算法来解这个方程，比如<strong>SMO（Sequential Minimal Optimization）</strong>就是其中一个比较著名的。至于SMO是如何做的，考虑到现代很多SVM的Pakage都是直接拿来用，秉承着<strong>前人付出了努力造了轮子就不重复造的核心精神</strong>，直接调用就好</p><h2 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h2><p>已经说明了如何求得方程，以上的推导形式都是建立在<strong>样本数据线性可分</strong>的基础上，如果样本数据<strong>你中有我我中有你</strong>（线性不可分），应该如何处理呢？这里就需要引入<strong>软间隔（Soft Margin）</strong>，意味着，<strong>允许支持向量机在一定程度上出错</strong></p><div align="center"><img src="//charlesliuyx.github.io/2017/09/19/支持向量机SVM学习笔记/SoftMargin.png" width="450px" alt="SoftMargin"></div><p>由上一节我们得知，约束为： $y_i(\mathbf w^T\vec x_i+b) \geqslant1,\;i = 1,2,\ldots,m$ ，目标是<strong>使目标函数可以在一定程度不满足这个约束条件</strong>，我们引入常数 $C$ 和 损失函数 $\ell_{0/1}(z)$ 为<code>0/1损失函数</code>，当z小于0函数值为1，否则函数值为0<br>$$\operatorname*{min}_{\mathbf w,b} \frac{1}{2}\lVert w \lVert^2 + C \sum_{i=1}^m \ell_{0/1}(y_i(\mathbf w^T\vec x_i+b) -1) \tag {7}$$</p><p>对于(7)式来说 $C \geqslant 0$ 是个常数，<strong>当C无穷大时，迫使所有样本均满足约束；当C取有限值时，允许一些样本不满足约束</strong></p><p>但 $\ell_{0/1}(z)$ 损失函数<strong>非凸、非连续</strong>，数学性质不好，<strong>不易直接求解</strong>，我们用其他一些函数来代替它，叫做<code>替代损失函数（surrogate loss）</code><br>$$\begin{align}& \text{hinge损失:} \ell_{hinge}(z) = max(0,1-z)\\& \text{指数损失:} \ell_{exp}(z) =  e^{-z}\\& \text{对数损失:} \ell_{log}(z) = log(1+e^{-z})\\\end{align}$$<br>三种常见损失函数如下图</p><div align="center"><img src="//charlesliuyx.github.io/2017/09/19/支持向量机SVM学习笔记/lossfunction.png" alt="损失函数" width="450px"></div><p>为了书写方便，我们引入<strong>松弛变量（slack variables）</strong>: $\xi_i \geqslant 0$，可将(7)式重写为<br>$$\operatorname*{min}_{\mathbf w,b,\xi_i} \frac{1}{2}\lVert w \lVert^2 + C \sum_{i=1}^m \xi_i \\ s.t. \quad y_i(\mathbf w^T\vec x_i+b) \geqslant 1 - \xi_i ;\; \xi_i \geqslant 0,\; i = 1,2,\ldots,m \tag{8}$$<br>(8)式就是常见的<strong>软间隔支持向量机</strong>，其中，每一个样本都有一个对应的松弛变量，用以<strong>表征该样本不满足约束的程度</strong>，求解的方法同理硬间隔支持向量机</p><h1 id="支持向量机扩展"><a href="#支持向量机扩展" class="headerlink" title="支持向量机扩展"></a>支持向量机扩展</h1><h2 id="核方法"><a href="#核方法" class="headerlink" title="核方法"></a>核方法</h2><p>以上我们求解的支持向量机都是在<strong>线性情况下</strong>的，那么<strong>非线性情况</strong>下如何处理？这里就引入：核方法</p><p>对于这样的问题，可以将<strong>样本从原始空间映射到一个更高为的特征空间，使得样本在这个特征空间内线性可分</strong>，<a href="https://v.qq.com/x/page/k05170ntgzc.html" target="_blank" rel="external">直观可视化解释</a></p><p>为了完成这个目的，令 $\phi(\mathbf x)$ 表示将 $\mathbf x$ <strong>映射后的特征向量</strong>，于是，在特征空间<strong>划分超平面</strong>所对应的模型可表示为：<br>$$f(\mathbf x) = \mathbf w^T \phi(\mathbf x) + b$$</p><p>同理上文中引入拉格朗日乘子，求解整个方程后可得<br>$$\begin{align}f(\mathbf x) &=   \mathbf w^T \phi(\mathbf x) + b \\&= \sum_{i=1}^m \lambda_i y_i \phi(\mathbf x_i)^T \phi(\mathbf x) + b \\&= \sum_{i=1}^m \lambda_i y_i k(\mathbf x,\mathbf x_i)+ b\end{align}$$</p><p>这里的函数 $k(\cdot,\cdot)$ 就是<strong>核函数（kernel function）</strong>，常见的核函数见下表</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">表达式</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center">线性核</td><td style="text-align:center"> $\boldsymbol x_i^T \boldsymbol x_j$ </td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">多项式核</td><td style="text-align:center"> $(\boldsymbol x_i^T \boldsymbol x_j)^d$ </td><td style="text-align:center">$d \geqslant 1$ 多项式次数</td></tr><tr><td style="text-align:center">高斯核</td><td style="text-align:center"> $exp(-\frac{\lVert\boldsymbol x_i - \boldsymbol x_j \lVert^2}{2\sigma^2})$ </td><td style="text-align:center">$\sigma&gt;0$  高斯核带宽</td></tr><tr><td style="text-align:center">拉普拉斯核</td><td style="text-align:center"> $exp(-\frac{\lVert\boldsymbol x_i - \boldsymbol x_j \lVert^2}{\sigma})$ </td><td style="text-align:center">$\sigma&gt;0$</td></tr><tr><td style="text-align:center">Sigmoid核</td><td style="text-align:center"> $tanh(\beta \boldsymbol x_i^T\boldsymbol x_j + \theta)$ </td><td style="text-align:center">$\beta&gt;0$ $\theta&gt;0$</td></tr></tbody></table><p>也可以通过<strong>函数组合</strong>得到这些值</p><h2 id="多类问题"><a href="#多类问题" class="headerlink" title="多类问题"></a>多类问题</h2><p>多类问题可以使用两两做支持向量机，再由所有的支持向量机投票选出这个类别的归属，被称为<code>one-versus-one approace</code>。</p><p>Reference<br><a href="https://www.zhihu.com/question/21094489" target="_blank" rel="external">知乎各类回答</a><br><a href="https://zh.wikipedia.org/wiki/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA" target="_blank" rel="external">Wiki百科</a><br>PRML<br>周志华-机器学习</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】13min - 19min&lt;br&gt;【内容简介】详解解读什么是支持向量机，如何解支持向量以及涉及的拉普拉斯乘子法，还有核方法的解读&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Theory" scheme="https://charlesliuyx.github.io/tags/Theory/"/>
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Dota2伤害类型详解</title>
    <link href="https://charlesliuyx.github.io/2017/09/18/Dota2%E4%BC%A4%E5%AE%B3%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://charlesliuyx.github.io/2017/09/18/Dota2伤害类型详解/</id>
    <published>2017-09-18T21:31:12.000Z</published>
    <updated>2017-09-19T04:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】5min 百科类<br>【内容简介】有关<code>Dota2</code>所有伤害来源的总结和互相作用总结，方便查阅</p><a id="more"></a><h1 id="伤害来源"><a href="#伤害来源" class="headerlink" title="伤害来源"></a>伤害来源</h1><h2 id="攻击伤害"><a href="#攻击伤害" class="headerlink" title="攻击伤害"></a>攻击伤害</h2><p>主要来自于普通物理攻击 - <strong>平A</strong></p><p><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#物理攻击伤害">具体计算方式</a></p><h2 id="技能伤害"><a href="#技能伤害" class="headerlink" title="技能伤害"></a>技能伤害</h2><p><a href="https://dota2-zh.gamepedia.com/%E6%8A%80%E8%83%BD%E4%BC%A4%E5%AE%B3" target="_blank" rel="external">详情参见</a></p><p>包含了所有来自技能的伤害，三种类型：魔法，物理和纯粹</p><h1 id="伤害类型"><a href="#伤害类型" class="headerlink" title="伤害类型"></a>伤害类型</h1><p><strong>互相作用机制表格</strong></p><table><thead><tr><th style="text-align:center">游戏机制</th><th style="text-align:center">物理攻击</th><th style="text-align:center">物理技能</th><th style="text-align:center">魔法伤害</th><th style="text-align:center">纯粹伤害</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#护甲">护甲</a></td><td style="text-align:center">降低</td><td style="text-align:center">降低</td><td style="text-align:center">正常</td><td style="text-align:center">正常</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#BD-Blocked-Damage-被格挡伤害">伤害格挡</a></td><td style="text-align:center">降低</td><td style="text-align:center">正常<a href="唯一的例外是`月刃`的弹射伤害和`虫群`的攻击伤害，会被格挡">^1</a></td><td style="text-align:center">正常</td><td style="text-align:center">正常</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#魔法抗性">魔法抗性</a></td><td style="text-align:center">正常</td><td style="text-align:center">正常</td><td style="text-align:center">降低</td><td style="text-align:center">正常</td></tr><tr><td style="text-align:center"><a href="https://dota2-zh.gamepedia.com/虚无" target="_blank" rel="external">虚无</a></td><td style="text-align:center">没有效果</td><td style="text-align:center">美国效果</td><td style="text-align:center">降低</td><td style="text-align:center">正常</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#闪避">闪避</a></td><td style="text-align:center">可能落空</td><td style="text-align:center">正常</td><td style="text-align:center">正常</td><td style="text-align:center">降低</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#致盲来源">致盲</a></td><td style="text-align:center">可能落空</td><td style="text-align:center">正常</td><td style="text-align:center">正常</td><td style="text-align:center">正常</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#伤害调整">伤害加深</a><a href="这些效果只针对那些直接对伤害进行操作的技能效果，即减免，加深或完全格挡，不包括通过增加/减少魔法抗性/护甲的技能">^2</a></td><td style="text-align:center">加深</td><td style="text-align:center">加深</td><td style="text-align:center">加深</td><td style="text-align:center">加深</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#伤害减免和加深">伤害减免</a><a href="这些效果只针对那些直接对伤害进行操作的技能效果，即减免，加深或完全格挡，不包括通过增加/减少魔法抗性/护甲的技能">^2</a></td><td style="text-align:center">降低</td><td style="text-align:center">降低</td><td style="text-align:center">降低</td><td style="text-align:center">降低</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#伤害无效化">伤害无效化</a><a href="这些效果只针对那些直接对伤害进行操作的技能效果，即减免，加深或完全格挡，不包括通过增加/减少魔法抗性/护甲的技能">^2</a></td><td style="text-align:center">没有效果</td><td style="text-align:center">没有效果</td><td style="text-align:center">没有效果</td><td style="text-align:center">没有效果</td></tr><tr><td style="text-align:center"><a href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/#魔法吸收护盾">魔法伤害护盾</a></td><td style="text-align:center">正常</td><td style="text-align:center">正常</td><td style="text-align:center">没有效果</td><td style="text-align:center">正常</td></tr><tr><td style="text-align:center"><a href="https://dota2-zh.gamepedia.com/%E6%97%A0%E6%95%8C" target="_blank" rel="external">无敌</a></td><td style="text-align:center">没有效果</td><td style="text-align:center">没有效果</td><td style="text-align:center">没有效果</td><td style="text-align:center">没有效果</td></tr><tr><td style="text-align:center"><a href="https://dota2-zh.gamepedia.com/%E6%8A%80%E8%83%BD%E5%85%8D%E7%96%AB" target="_blank" rel="external">技能免疫</a></td><td style="text-align:center">正常</td><td style="text-align:center">不定</td><td style="text-align:center">不定</td><td style="text-align:center">不定</td></tr></tbody></table><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><p>与护甲和伤害格挡有关，虚无和一些技能可以造成物理免疫，召唤单位和守卫的平A也是物理攻击</p><h3 id="物理免疫技能"><a href="#物理免疫技能" class="headerlink" title="物理免疫技能"></a>物理免疫技能</h3><p><code>炼金术士：酸性喷雾</code> <code>炼金术士：不稳定化合物</code> <code>敌法师：法力损毁</code> <code>兽王：野性飞斧</code> <code>赏金猎人：暗影步</code> <code>钢背兽：针刺扫射</code> <code>人马：反击</code> <code>克林克次：灼热之箭</code> <code>戴泽：剧毒之触</code> <code>戴泽：暗影波</code> <code>死亡先知：驱使恶灵</code> <code>龙骑士：古龙形态溅射</code> <code>上古巨神：裂地沟壑</code> <code>上古巨神：回音重踏</code> <code>灰烬之灵：无影拳</code> <code>主宰：无敌斩</code> <code>昆卡：潮汐使者</code> <code>拉席克：恶魔赦令</code> <code>噬魂鬼：盛宴</code> <code>露娜：月刃</code> <code>马格纳斯：加强力量溅射</code> <code>司夜刺客：复仇</code> <code>剃刀：风暴之眼</code> <code>力丸：背刺</code> <code>斯拉达：鱼人碎击</code> <code>斯拉达：重击</code> <code>狙击手：爆头</code> <code>熊灵：缠绕之爪</code> <code>斯温：巨力挥舞</code> <code>圣堂刺客：隐匿</code> <code>潮汐猎人：锚机</code> <code>熊战士：怒意狂击</code> <code>冥界亚龙：幽冥剧毒</code> <code>编织者：虫群</code> </p><h2 id="魔法"><a href="#魔法" class="headerlink" title="魔法"></a>魔法</h2><p>大多数技能都是魔法伤害，虚无状态会承受更多伤害</p><p>在纯粹和物理技能中未提及的都是魔法伤害</p><h2 id="纯粹"><a href="#纯粹" class="headerlink" title="纯粹"></a>纯粹</h2><p>纯粹伤害能作用与技能免疫单位，不能作用于无敌单位</p><p><code>斧王-反击螺旋</code> <code>祸乱之源：蚀脑</code> <code>祸乱之源：噩梦</code> <code>嗜血狂魔：血之祭祀</code> <code>嗜血狂魔：割裂</code> <code>陈：忠诚考验</code> <code>末日使者：末日</code> <code>魅惑魔女：推进</code> <code>谜团：午夜凋零</code> <code>谜团：黑洞</code> <code>祈求者：炎阳冲击</code> <code>杰奇洛：A烈焰焚身</code> <code>莉娜：A神灭斩</code> <code>美杜莎：（石化）秘术异蛇</code> <code>司夜刺客：尖刺外壳</code> <code>全能骑士：洗礼</code> <code>殁境神蚀者：奥术天球</code> <code>帕吉：肉钩</code> <code>痛苦女王：超声冲击波</code> <code>沉默术士：智慧之刃</code> <code>幽鬼：荒芜</code> <code>圣堂刺客：灵能之刃</code> <code>伐木机：锯齿飞轮</code> <code>伐木机：伐木锯链</code> <code>伐木机：死亡旋风</code> <code>修补匠：激光</code> <code>骨灰</code></p><h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><p>是一种特殊标记，为的是与其他技能区分开来</p><h2 id="生命移除标记"><a href="#生命移除标记" class="headerlink" title="生命移除标记"></a>生命移除标记</h2><p>某些生命移除标记的技能可以<strong>立即杀死幻想</strong></p><p><code>干扰者：恶念瞥视</code> <code>莱恩：妖术</code> <code>莱恩：法力抽取</code> <code>美杜莎：石化凝视</code> <code>帕格纳：生命吸取</code> <code>羊刀：变羊</code> <code>暗影萨满：变羊</code></p><p>有些技能<strong>利用生命移除</strong>来制造<strong>生命消耗效果</strong>，通常都是<strong>非致命伤害</strong>，<strong>伤害类型也是纯粹</strong>，被标记为生命移除</p><p><code>臂章：扣血</code> <code>哈斯卡：沸血之矛对自身</code> <code>艾欧：过载</code> <code>凤凰：凤凰冲击</code> <code>凤凰：烈火精灵</code> <code>凤凰：烈日炙烤</code> <code>魂戒：献身</code> <code>工程师：自爆起飞</code> <code>不朽尸王：噬魂</code></p><h2 id="不反弹标记"><a href="#不反弹标记" class="headerlink" title="不反弹标记"></a>不反弹标记</h2><p>不反弹标记会使得一些受到伤害事件不会与带有不反弹标记的伤害相互作用，这防止了无限伤害循环(</p><p><code>刃甲：反弹伤害</code> <code>司夜刺客：尖刺外壳</code> <code>冥界亚龙：腐蚀皮肤</code> <code>术士：致命链接</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】5min 百科类&lt;br&gt;【内容简介】有关&lt;code&gt;Dota2&lt;/code&gt;所有伤害来源的总结和互相作用总结，方便查阅&lt;/p&gt;
    
    </summary>
    
      <category term="Dota2" scheme="https://charlesliuyx.github.io/categories/Dota2/"/>
    
    
      <category term="Dota2" scheme="https://charlesliuyx.github.io/tags/Dota2/"/>
    
      <category term="Mechanism" scheme="https://charlesliuyx.github.io/tags/Mechanism/"/>
    
  </entry>
  
  <entry>
    <title>【直观详解】机器学习分类器性能指标详解</title>
    <link href="https://charlesliuyx.github.io/2017/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%AF%A6%E8%A7%A3/"/>
    <id>https://charlesliuyx.github.io/2017/09/12/机器学习分类器性能指标详解/</id>
    <published>2017-09-12T20:05:32.000Z</published>
    <updated>2017-09-21T06:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】16 - 26 min<br>【内容简介】系统详解分类器性能指标，什么是<code>准确率 - Accuracy</code>、<code>精确率 - Precision</code>、<code>召回率 - Recall</code>、<code>F1值</code>、<code>ROC曲线</code>、<code>AUC曲线</code>、<code>误差 - Error</code>、<code>偏差 - Bias</code>、<code>方差 - Variance</code>及<code>Bias-Variance Tradeoff</code></p><a id="more"></a><p>在任何领域，评估（Evaluation）都是一项很重要的工作。在Machine Learning领域，定义了许多概念并有很多手段进行评估工作</p><h1 id="混淆矩阵-Confusion-Matrix"><a href="#混淆矩阵-Confusion-Matrix" class="headerlink" title="混淆矩阵 - Confusion Matrix"></a>混淆矩阵 - Confusion Matrix</h1><p><strong>准确率</strong>定义：对于给定的测试数据集，分类器<strong>正确分类的样本数</strong>与<strong>总样本数</strong>的之比</p><p>通过准确率，的确可以在一些场合，从某种意义上得到一个分类器是否有效，但它并不总是能有效的评价一个分类器的工作。一个例子，Google抓取了100个特殊页面，它的索引中有10000000页面。随机抽取一个页面，这是不是特殊页面呢？如果我们的分类器确定一个分类规则：“只要来一个页面就判断为【不是特殊页面】”，这么做的效率非常高，如果计算按照准确率的定义来计算的话，是(9,999,900/10,000,000) = 99.999%。虽然高，但是这不是我们并不是我们真正需要的值，就需要新的定义标准了</p><p>对于一个二分类问题来说，将实例分为<strong>正类（Positive/+）</strong>或<strong>负类（Negative/-）</strong>，但在使用分类器进行分类时会有四种情况</p><ul><li>一个实例是正类，并被预测为正类，记为真正类（True Positive <strong>TP/T+</strong>）</li><li>一个实例是正类，但被预测为负类，记为假负类（False Negative <strong>FN/F-</strong>）</li><li>一个实例是负类，但被预测为正类，记为假正类（False Positive <strong>FP/F+</strong>）</li><li>一个实例是负类，但被预测为负类，记为真负类（True Negative <strong>TN/F-</strong>）</li></ul><p><strong>TP和TN中的真表示分类正确，同理FN和FP表示分类错误的</strong></p><p>为了全面的表达所有二分问题中的指标参数，下列矩阵叫做<strong>混淆矩阵 - Confusion Matrix</strong>，目的就是看懂它，搞清楚它，所有模型评价参数就很清晰了</p><?xml version="1.0" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100%" height="100%" viewbox="0 5.5 96 48"> <title>DiagnosticTesting Diagram</title> <desc>Relationships between various measures of diagnostic testing by CMG Lee. In the SVG image, hover over a block or relation to highlight it.</desc> <style type="text/css">  #mainsvg         { font-family:Helvetica,Arial,sans-serif; font-size:6px; text-anchor:middle;                  stroke-linejoin:round; stroke-linecap:round; stroke-width:0.7; fill:none;                  stroke-opacity:1;    fill-opacity:1;    }  #mainsvg:hover   { stroke-opacity:0.25; fill-opacity:0.25; }  .active:hover { stroke-opacity:1;    fill-opacity:1;    }  text          { fill:#000000; cursor:default; }  .label        { stroke:none; fill:#000000 }  .op           { stroke-width:0.15; font-size:5px; font-weight:bold; } </style> <defs>  <rect id="box" x="-6" y="-1.3" width="12" height="2.6" stroke-width="2.8" stroke-opacity="1"/>  <g id="top"><path d="M  0, 0 q  0,-4  5,-4 h  30 q  5, 0   5, 4 m -20,  0 q  0,-4 -5,-4" stroke-dasharray="0.1,1"/><text class="op" x="8" y="-3" dy="0.7ex">+</text></g>  <g id="bottom1"><path d="M  0, 0 q  0, 4 -5, 4 h -50 q -5, 0  -5,-4 m  20,  0 q  0, 4  5, 4" stroke-dasharray="2,1"/><text class="op" x="0" y="4" dy="0.7ex">&#247;</text></g>  <g id="bottom2"><path d="M  0, 0 q  0, 5 -5, 5 h -69 q -5, 0  -5,-5 m  40,  0 q  0, 5  5, 5"/><text class="op" x="0" y="4.5" dy="0.7ex">&#247;</text></g>  <g id="bottom3"><path d="M  0, 0 q  0, 4 -5, 4 h -30 q -5, 0  -5,-4 m  20,  0 q  0, 4  5, 4"/><text class="op" x="0" y="4" dy="0.7ex">&#247;</text></g>  <g id="left"><path d="M  0, 0 q -9, 0 -9, 5 v  10 q  0, 5   9, 5 m   0,-10 q -9, 0 -9,-5" stroke-dasharray="0.1,1"/><text class="op" x="-8.5" y="1" dy="0.7ex">+</text></g>  <g id="right1"><path d="M  0, 0 q  9, 0  9,-5 v -20 q  0,-5  -9,-5 m   0, 10 q  9, 0  9, 5" stroke-dasharray="2,1"/><text class="op" x="8.5" y="-1" dy="0.7ex">&#247;</text></g>  <g id="right2"><path d="M  0, 0 q 10, 0 10,-5 v -30 q  0,-5 -10,-5 m   0, 20 q 10, 0 10, 5"/><text class="op" x="8.5" y="0" dy="0.7ex">&#247;</text></g>  <g id="acc"><path d="M  0, 0 q  0, 5 -5, 5 h -69 q -5, 0  -5,-5 m  22, 10 q  0,-5  5,-5                           M  0, 0 q  0, 5 -5, 5 h -17 q -5, 0  -5, 5 v       5 q  0, 1 -1, 1 h -5 q -4,0 -4,4"/><text class="op" x="2.5" y="4.5" dy="0.7ex">+,&#247;</text></g>  <g id="dor"><path d="M  0, 0 q  0, 4 -5, 4 h  -5 q -5, 0  -5,-4 m   0,  8 q  0,-4  5,-4" stroke-dasharray="4,1"/><text class="op" x="0" y="4" dy="0.7ex">&#247;</text></g>  <g id="f1"><path d="M  0, 0 q -10,0 -9,-4 v -22 q  0,-2  -2,-2                           M -9,-3 q -1,-1 -2,-1 h -43 q -5, 0  -5,-5" stroke-dasharray="0.1,1"/></g> </defs> <circle cx="0" cy="0" r="99999" fill="#999999"/> <g id="mainsvg">  <g class="active" transform="translate(88,48)" stroke="#ddffdd"><use xlink:href="#f1"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">F1 s.</text><title>F1 score = 2 / (1 / Recall + 1 / Precision)</title></g>  <g class="active" transform="translate(88,10)" stroke="#cceecc"><use xlink:href="#acc"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">ACC</text><title>Accuracy = (&#931; True positive + &#931; True negative) / &#931; Total population</title></g>  <g class="active" transform="translate(88,39)" stroke="#dddddd"><use xlink:href="#dor"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">DOR</text><title>Diagnostic odds ratio = Positive likelihood ratio / Negative likelihood ratio</title></g>  <g class="active" transform="translate(70,39)" stroke="#eeeeee"><use xlink:href="#bottom3"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">LR+</text><title>Positive likelihood ratio = True positive rate / False positive rate</title></g>  <g class="active" transform="translate(70,48)" stroke="#cccccc"><use xlink:href="#bottom3"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">LR&#8722;</text><title>Negative likelihood ratio = False negative rate / True negative rate</title></g>  <g class="active" transform="translate(88,20)" stroke="#cceeff"><use xlink:href="#bottom2"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">FDR</text><title>False discovery rate = &#931; False positive / &#931; Predicted condition positive</title></g>  <g class="active" transform="translate(70,20)" stroke="#ccffee"><use xlink:href="#bottom1"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">PPV</text><title>Positive predictive value, Precision = &#931; True positive / &#931; Predicted condition positive</title></g>  <g class="active" transform="translate(88,30)" stroke="#aaddcc"><use xlink:href="#bottom2"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">NPV</text><title>Negative predictive value = &#931; True negative / &#931; Predicted condition negative</title></g>  <g class="active" transform="translate(70,30)" stroke="#eeddee"><use xlink:href="#bottom1"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">FOR</text><title>False omission rate = &#931; False negative / &#931; Predicted condition negative</title></g>  <g class="active" transform="translate(30,39)" stroke="#eeffcc"><use xlink:href="#right1"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">TPR</text><title>True positive rate, Recall, Sensitivity, probability of detection = &#931; True positive / &#931; Condition positive</title></g>  <g class="active" transform="translate(30,48)" stroke="#ffeecc"><use xlink:href="#right2"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">FNR</text><title>False negative rate, Miss rate = &#931; False negative / &#931; Condition positive</title></g>  <g class="active" transform="translate(50,39)" stroke="#eeddbb"><use xlink:href="#right1"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">FPR</text><title>False positive rate, Fall-out, probability of false alarm = &#931; False positive / &#931; Condition negative</title></g>  <g class="active" transform="translate(50,48)" stroke="#ddeebb"><use xlink:href="#right2"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">TNR</text><title>True negative rate, Specificity = &#931; True negative / &#931; Condition negative</title></g>  <g class="active" transform="translate(70,10)" stroke="#eeeecc"><use xlink:href="#bottom1"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">prev.</text><title>Prevalence = &#931; Condition positive / &#931; Total population</title></g>  <g class="active" transform="translate(10,10)" stroke="#dddddd"><use xlink:href="#top"/><use xlink:href="#left"/><use xlink:href="#box"/><text class="label" x="0" y="0.4ex">pop.</text><title>Total population = Condition positive + Condition negative = Predicted condition positive + Predicted condition negative 样本空间 = 正类 + 负类 = 预测结果正类 + 预测结果负类</title></g>  <g class="active" transform="translate(10,30)" stroke="#aadddd"><use xlink:href="#top"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">Pc&#8722;</text><title>Predicted condition negative = False negative + True negative</title></g>  <g class="active" transform="translate(10,20)" stroke="#ccffff"><use xlink:href="#top"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">Pc+</text><title>Predicted condition positive = True positive + False positive</title></g>  <g class="active" transform="translate(30,10)" stroke="#ffffcc"><use xlink:href="#left"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">C+</text><title>Condition positive = True positive + False negative</title></g>  <g class="active" transform="translate(50,10)" stroke="#ddddaa"><use xlink:href="#left"/><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">C&#8722;</text><title>Condition negative = False positive + True negative</title></g>  <g class="active" transform="translate(50,30)" stroke="#bbeebb"><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">T&#8722;</text><title>负类中预测正确的部分</title></g>  <g class="active" transform="translate(30,30)" stroke="#ffdddd"><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">F&#8722;</text><title>负类中预测错误的部分</title></g>  <g class="active" transform="translate(50,20)" stroke="#eedddd"><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">F+</text><title>正类中预测错误的部分</title></g>  <g class="active" transform="translate(30,20)" stroke="#ccffcc"><use xlink:href="#box"/><text class="label" x="0" y="0.5ex">T+</text><title>正类中预测正确的部分</title></g> </g></svg><p>通过上面的的讨论已经有<code>T+:TP</code> <code>F+:FP</code> <code>T-:TN</code> <code>F-:FN</code> <code>C+:样本正类</code> <code>C-:样本负类</code> <code>Pc+:预测正类</code> <code>Pc-:预测负类</code> </p><p>用样本中的正类和负类进行计算的定义</p><table><thead><tr><th style="text-align:center">缩写</th><th style="text-align:center">全称</th><th style="text-align:center">等价称呼</th><th style="text-align:center">计算公式</th></tr></thead><tbody><tr><td style="text-align:center">TPR</td><td style="text-align:center">True Positive Rate</td><td style="text-align:center">真正类率 <code>Recall</code> <code>Sensitivity</code></td><td style="text-align:center">$ \frac {\sum T+}{\sum C+}$</td></tr><tr><td style="text-align:center">FNR</td><td style="text-align:center">False Negative Rate</td><td style="text-align:center">假负类率<code>Miss rate</code> <code>Type rs  error</code></td><td style="text-align:center">$ \frac {\sum F-}{\sum C+}$</td></tr><tr><td style="text-align:center">FPR</td><td style="text-align:center">False Positive Rate</td><td style="text-align:center">假正类率<code>fall-out</code> <code>Type 1 error</code></td><td style="text-align:center">$ \frac {\sum F+}{\sum C-}$</td></tr><tr><td style="text-align:center">TNR</td><td style="text-align:center">Tre Negative Rate</td><td style="text-align:center">真负类率<code>Specificity</code></td><td style="text-align:center">$ \frac {\sum T-}{\sum C-}$</td></tr></tbody></table><p>用预测结果的正类和负类进行计算的定义</p><table><thead><tr><th style="text-align:center">缩写</th><th style="text-align:center">全称</th><th style="text-align:center">等价称呼</th><th style="text-align:center">计算公式</th></tr></thead><tbody><tr><td style="text-align:center">PPV</td><td style="text-align:center">Positive Predictive Value</td><td style="text-align:center">正类预测率<code>Precision</code></td><td style="text-align:center">$ \frac {\sum T+}{\sum Pc+}$</td></tr><tr><td style="text-align:center">FOR</td><td style="text-align:center">False Omission Rata</td><td style="text-align:center">假错误率</td><td style="text-align:center">$ \frac {\sum F-}{\sum Pc-}$</td></tr><tr><td style="text-align:center">FDR</td><td style="text-align:center">False Discovery Rate</td><td style="text-align:center">假发现率</td><td style="text-align:center">$ \frac {\sum F+}{\sum Pc+}$</td></tr><tr><td style="text-align:center">NPV</td><td style="text-align:center">Negative Predictive Value</td><td style="text-align:center">负类预测率</td><td style="text-align:center">$ \frac {\sum T-}{\sum Pc-}$</td></tr></tbody></table><p>其他定义概念</p><table><thead><tr><th style="text-align:center">缩写</th><th style="text-align:center">全称</th><th style="text-align:center">等价称呼</th><th style="text-align:center">计算公式</th></tr></thead><tbody><tr><td style="text-align:center">ACC</td><td style="text-align:center">Accuracy</td><td style="text-align:center">准确率</td><td style="text-align:center">$ \frac {\sum (T+) + \sum {T-}}{样本空间}$</td></tr><tr><td style="text-align:center">LR+</td><td style="text-align:center">Positive Likelihood Ratio</td><td style="text-align:center">正类似然比</td><td style="text-align:center">$ \frac {TPR}{FPR}$</td></tr><tr><td style="text-align:center">LR-</td><td style="text-align:center">Negative likelihood ratio</td><td style="text-align:center">负类似然比</td><td style="text-align:center">$ \frac {FNR}{TNR}$</td></tr><tr><td style="text-align:center">DOR</td><td style="text-align:center">Diagnostic odds ratio</td><td style="text-align:center">诊断胜算比</td><td style="text-align:center">$ \frac {LR+}{LR-}$</td></tr><tr><td style="text-align:center">F1 score</td><td style="text-align:center">$F_1$ test measure</td><td style="text-align:center">F1值</td><td style="text-align:center">$\frac{2}{\frac{1}{recall}+\frac{1}{precision}}$</td></tr><tr><td style="text-align:center">MCC</td><td style="text-align:center">Matthews Correlation coefficient</td><td style="text-align:center">马修斯相关性系数</td><td style="text-align:center">$\frac{TP \times TN - FP \times FN}{\sqrt {(TP + FP)(TP + FN)(TN + FP)(TN +FN)}}$</td></tr></tbody></table><p><code>LR+/-</code>指的是似然比，<strong>LR+ 越大表示模型对正类的分类越好，LR-越大表示模型对负类的分类效果越好</strong></p><p><code>F1值</code>是精确值和召回率的调和均值，其实原公式是 $F_\beta = (1 + \beta^2)\frac{precision \times recall}{(\beta^2recall)+recall}$，这里的β表示：<strong>召回率的权重是准确率的β倍</strong>。即F值是一种精确率和召回率的综合指标，权重由β决定</p><p><code>MCC</code>值在[-1,1]之间，靠近1表示完全预测正确，靠近-1表示完全悖论，0表示随机预测</p><p>最终为了不那么麻烦，说人话，还是<strong>一图胜千言</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/12/机器学习分类器性能指标详解/Precisionrecall.png" alt="Precision - Recall" title="">                </div>                <div class="image-caption">Precision - Recall</div>            </figure><p>图片详解：</p><blockquote><p>左边暗一些部分的点都是<strong>真正的正类</strong>，右边亮一些部分的点都是<strong>真正的负类</strong></p><p>中间的一个圆圈就是我们的<strong>正类分类器</strong>：注意，这个<strong>圈是的预测结果都是正类</strong>，也就是说在这个分类器看来，它选择的这些元素都是它所认为的<strong>正类</strong>，对应的，当然是圈以外的部分，也就是<strong>预测结果是负类的部分</strong></p><p>底下的Precision和Recall示意图也相当的直观，看一下就能明白</p></blockquote><h1 id="ROC-Curve"><a href="#ROC-Curve" class="headerlink" title="ROC Curve"></a>ROC Curve</h1><p>ROC - Receiver Operating Characteristic Curve，接受者操作特征曲线，ROC曲线</p><p>这个曲线乍看下为啥名称那么奇怪呢，原来这个曲线最早是由二战中的电子工程师和雷达工程师发明的，用来侦测战场上的敌军飞机，舰艇等，是一种信号检测理论，还被应用到心理学领域做知觉检测。</p><h2 id="什么是ROC曲线"><a href="#什么是ROC曲线" class="headerlink" title="什么是ROC曲线"></a>什么是ROC曲线</h2><p>ROC曲线和混淆矩阵息息相关，上一部分已经详细解释了相关内容，这里直接说明ROC曲线的横坐标和纵坐标分别是什么</p><p>横坐标：FPR假正类率，纵坐标：TPR真正类率</p><p>初看之下你不懂一个曲线表示的什么意思，那么看几个特征点或特殊曲线是一个非常好的方法。按照这种方法来分析ROC曲线：</p><ul><li>第一个点：(0,1)，<code>FPR=0</code> <code>TPR=1</code> ，这意味着所有的正类全部分类正确，或者说<strong>这是一个完美的分类器</strong>，将所有的样本都分类正确了</li><li>第二个点：(1,0)， <code>FPR=1</code> <code>TPR=0</code> ，和第一个点比较，这是第一个点的完全反面，意味着是个<strong>最糟糕的分类器</strong>，将所有的样本都分类错误了（但其实可以直接取反，就是最好的模型，因为是二分类问题）</li><li>第三个点：(0,0)，<code>FPR=0</code> <code>TPR=0</code> 也就是原点，这个点表示的意思是，<strong>分类器预测所有的样本都为负类</strong></li><li>第四个点：(1,1)，<code>FPR=1</code> <code>TPR=1</code>，和第三个点对应，表示<strong>分类器预测所有的样本都为正类</strong></li><li>一条线：y=x。这<strong>条对角线上的点</strong>实际上就是一个<strong>采用随机猜测策略的分类器的结果</strong></li></ul><p>总结来说，ROC曲线的面积越大，模型的效果越好；ROC曲线光滑以为着Overfitting越少</p><p>还是一图胜千言</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/12/机器学习分类器性能指标详解/ROCfig.png" alt="ROC曲线解释" title="">                </div>                <div class="image-caption">ROC曲线解释</div>            </figure><p>$TPR = \frac{TP}{TP+FN}$ $FPR = \frac{FP}{FP+TN}$ 蓝色图像是正类分类器的概率分布，红色图像负类分类器的概率分布，竖直的黑线是阈值（Threshold），<strong>二分类分类器的输出就是一个取值在[0,1]间的值（概率）</strong>，我们将黑线从0移动到1，就能得出一条曲线，这条线就是ROC曲线</p><p>如果问这个<strong>分类器画成的图像为</strong>何是一个类似帽子的形状，例子是最佳的说明方法，我们就来算一个ROC曲线看看，下图是20个测试样本的结果，“Class”一栏表示每个测试样本真正的标签（p表示正类，n表示负类），“Score”表示每个测试样本属于正样本的概率，Inst#是序号数</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/12/机器学习分类器性能指标详解/score-ranking.png" alt="example-data" title="">                </div>                <div class="image-caption">example-data</div>            </figure><p>接下来，我们从高到低，<strong>依次将“Score”值作为阈值threshold</strong>，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的<strong>第4个样本</strong>，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。<strong>每次选取一个不同的threshold，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。</strong>这样一来，我们一共得到了<strong>20组FPR和TPR的值（和你的测试样本的数量有关）</strong>，将它们画在ROC曲线的结果如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/12/机器学习分类器性能指标详解/roc-example.png" alt="example-roc-curve" title="">                </div>                <div class="image-caption">example-roc-curve</div>            </figure><p>当然我们也可以曲很多个阈值画曲线，不一定非要从测试样本的结果中取20个</p><h2 id="为什么使用ROC曲线"><a href="#为什么使用ROC曲线" class="headerlink" title="为什么使用ROC曲线"></a>为什么使用ROC曲线</h2><p>ROC曲线有一个很好的特性：当测试集中的<strong>正负样本的分布变化</strong>的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现<strong>类不平衡（class imbalance）现象</strong>，即<strong>负样本比正样本多很多（或者相反）</strong>，而且<strong>测试数据中的正负样本的分布也可能随着时间变化</strong>。下图是ROC曲线和Precision-Recall曲线的对比：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/12/机器学习分类器性能指标详解/roc-and-precall.png" alt="ROC-PrecisionRecall" title="">                </div>                <div class="image-caption">ROC-PrecisionRecall</div>            </figure><p>在上图中，<strong>(a)和(c)为ROC曲线</strong>，<strong>(b)和(d)为Precision-Recall曲线</strong>。</p><p>(a)和(b)展示的是<strong>分类其在原始测试集（正负样本分布平衡）的结果</strong>，(c)和(d)是将测试集中<strong>负样本的数量增加到原来的10倍后</strong>，分类器的结果。可以明显的看出，<strong>ROC曲线基本保持原貌，而Precision-Recall曲线则变化较大</strong>，记住这个结论即可</p><h1 id="PRC-Curve"><a href="#PRC-Curve" class="headerlink" title="PRC Curve"></a>PRC Curve</h1><p>在上面提到了一个指标，PRC - Precision-Recall 曲线，画法和ROC很相似，但是使用值是Precision和Recall</p><h1 id="AUC-Value"><a href="#AUC-Value" class="headerlink" title="AUC Value"></a>AUC Value</h1><p>AUC - Area Under Curve被定义为ROC曲线下的面积</p><p>AUC在[0.5,1]之间，这是因为ROC曲线一般都处于y=x这条直线的上方（否则这个做分类器的人连简单的取非都不会真可以去死了）</p><p>AUC值越大，证明这个模型越好</p><h1 id="Bias-Variance-Tradeoff"><a href="#Bias-Variance-Tradeoff" class="headerlink" title="Bias-Variance Tradeoff"></a>Bias-Variance Tradeoff</h1><p>三个名词，<code>Error误差</code> <code>Bisa偏差</code> <code>Variance方差</code></p><h2 id="三个名词表示了什么"><a href="#三个名词表示了什么" class="headerlink" title="三个名词表示了什么"></a>三个名词表示了什么</h2><p>再来一次，一图胜千言</p><div align="center"><br><br><img src="//charlesliuyx.github.io/2017/09/12/机器学习分类器性能指标详解/BV-Tradeoff.png" alt="Bias-Variance-Tradeoff" width="450px"><br><br></div><ul><li><strong>准</strong>：Bias 描述的是<strong>根据样本</strong>训练的模型的<strong>输出预测结果的期望</strong>与<strong>样本真实结果</strong>的差距，说人话，这个模型对样本拟合的好不好。想在Bias上表现好，降低Bias，就是复杂化模型，增加模型的参数，但这样容易过拟合（Overfitting）<strong>Low Bias对应的就是点都在靶心附近，所以瞄的都是准的，但手不一定稳</strong></li><li><strong>确</strong>：Variance 描述的是<strong>根据样本</strong>训练的模型在<strong>测试集上的表现（泛化能力） </strong>，想在Variance上表现好，降低Variance，需要简化模型，减少模型的参数，这样做容易欠拟合，对应上图的High Bias，点偏离的中心。<strong>Low Variance对应的是点打的都很集中，但不一定在靶心附近，手很稳，但是瞄的不准</strong></li></ul><p>要准确表达这两个定义的含义必须要使用公式化的语言，不得不感叹，<strong>在准确描述世界运行的规律这件事上，数学比文字要准确并且无歧义的多，文字（例子）直观啰嗦，数学（公式）准确简介</strong></p><p>我们假设有这样的一个函数，$y=f(x) + \epsilon$ ，其中噪声 $\epsilon$ 均值为0，<strong>方差为 $\sigma^2$</strong> </p><p>我们的目的是去找到一个函数 $\hat {f}(x)$ <strong>尽可能接近</strong> $f(x)$ ，我们可以用<strong>均方误差（MSE）或者交叉熵，或者DL散度</strong>来表示这个接近程度，我们希望 $(y - \hat f(x) )^2$ 对样本空间内的所有样本和测试集中的所有样本都<strong>最小</strong></p><p>机器学习核心就是用各种不同的算法去找这个 $\hat f$，希望最小，那就使用一个公式来表征这个值得大小，<strong>即期望，<font color="#FF0000">也称Total Error（误差），在机器学习的训练中，这个值是评判模型好坏最重要：</font></strong><br>$$<br>E[(y - \hat f(x))^2] = Bias[\hat f(x)]^2 + Var[\hat f(x)] + \sigma^2<br>$$</p><p>其中 $Bias[\hat f(x)] = E[\hat f(x) - f(x)]$，且 $Var[\hat f(x)] = E[\hat f(x)^2] - E[\hat f(x)]^2$</p><p><code>Bias-Variance Tradeoff</code>作为机器学习一个核心训练的观点或者说概念，<strong>推导觉得还是十分重要</strong>，整理如下</p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>为了公式简介，把 $f(x)$ 与 $\hat f(x)$ 简写为 $f$ 与 $\hat f$ ，记随机变量为 $X$，有<br>$$<br>Var[X] = E[X^2] - E[X]^2 \implies E[X^2] = Var[X] + E[X]^2<br>$$</p><p>因为 $f$ 是一个已经确定的函数，所以 $E[f] = f$ 成立 </p><p>根据 $y = f + \epsilon$ 和 $E[\epsilon] = 0$ 有<br>$$<br>E[y] = E[f + \epsilon] = E[f] = f<br>$$<br>噪声的方差 $ Var[\epsilon] = \sigma^2$<br>$$Var[y] = E[(y-E[y])^2] = E[(y - f)^2] = E[(f + \epsilon - f)^2] = E[\epsilon^2] = Var[\epsilon] + E[\epsilon]^2 = \sigma^2$$由于 $\epsilon$ 和 $\hat f$ 互相独立$$\begin{align}E[(y - \hat f)^2] & = E[y^2 + \hat f^2 - 2y\hat f] \\ & = E[y^2] + E[\hat f^2] - E[2y\hat f] \\& = Var[y] + E[y]^2 + Var[\hat f] + E[\hat f]^2 - 2fE[\hat f] \\& = Var[y] + Var[\hat f] + (f^2 - 2fE[\hat f] + E[\hat f]^2) \\& = Var[y] + Var[\hat f] + (f - E[\hat f])^2 \\& = \sigma^2 + Var[\hat f] + Bias[\hat f]^2\end{align}$$</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉在实际使用中，你不需要去自己写代码来画这些曲线，只要是框架是一定整合了这些值得结果，但是知其然知其所以然，越了解它是如何画的，越能<strong>处理奇怪的特殊情况</strong></p><p>常见的处理方式是记下来所有指标的结果，即这些指标怎么变，表示了模型的那些方面好或者坏的结论，但是如果在特殊的问题出现了不在你看的结果中的情况可能还是会捉襟见肘，还是脚踏实地，能看见更大的世界！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】16 - 26 min&lt;br&gt;【内容简介】系统详解分类器性能指标，什么是&lt;code&gt;准确率 - Accuracy&lt;/code&gt;、&lt;code&gt;精确率 - Precision&lt;/code&gt;、&lt;code&gt;召回率 - Recall&lt;/code&gt;、&lt;code&gt;F1值&lt;/code&gt;、&lt;code&gt;ROC曲线&lt;/code&gt;、&lt;code&gt;AUC曲线&lt;/code&gt;、&lt;code&gt;误差 - Error&lt;/code&gt;、&lt;code&gt;偏差 - Bias&lt;/code&gt;、&lt;code&gt;方差 - Variance&lt;/code&gt;及&lt;code&gt;Bias-Variance Tradeoff&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Theory" scheme="https://charlesliuyx.github.io/tags/Theory/"/>
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>【直观详解】信息熵、交叉熵和相对熵</title>
    <link href="https://charlesliuyx.github.io/2017/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E6%81%AF%E7%86%B5%E3%80%81%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8C%E7%9B%B8%E5%AF%B9%E7%86%B5/"/>
    <id>https://charlesliuyx.github.io/2017/09/11/什么是信息熵、交叉熵和相对熵/</id>
    <published>2017-09-11T07:25:49.000Z</published>
    <updated>2017-09-21T05:59:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】10min - 13min<br>【内容简介】使用一个现实中直观的例子详解<strong>信息熵、交叉熵及相对熵</strong>的核心概念，读完后，希望能帮助你建立起这三个概念的固有直觉，不再疑惑</p><p>要完成题目的最终解释，必须从<strong>熵</strong>这个神奇的概念开始讲起</p><a id="more"></a><h1 id="什么是熵-Entropy"><a href="#什么是熵-Entropy" class="headerlink" title="什么是熵 - Entropy"></a>什么是熵 - Entropy</h1><h2 id="词源-最初来源于热力学"><a href="#词源-最初来源于热力学" class="headerlink" title="词源 - 最初来源于热力学"></a>词源 - 最初来源于热力学</h2><p>Entropy来源于希腊语，原意：内向，即：一个系统不受外部干扰时<strong>往内部稳定状态发展</strong>的特性。定义的其实是一个热力学的系统<strong>变化的趋势</strong></p><p>$$<br>\Delta S = \frac{Q}{T} = \frac{热量}{温度} \tag{1-1}<br>$$<br>1923年，德国科学家普朗克来中国讲学用到<code>entropy</code>这个词，胡刚复教授看到这个公式，<strong>创造了“熵”字</strong>，因为“火”和热量有关，定义式又是热量比温度，相当自洽</p><h2 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h2><p>信息论中，熵是接受的每条消息中<strong>包含的信息的平均值</strong>。又被称为信息熵、信源熵、平均自信息量。可以被理解为<strong>不确定性的度量</strong>，熵越大，信源的分布越随机</p><p>1948年，由克劳德·爱尔伍德·香农将热力学中的熵引入信息论，所以也叫做：香农熵</p><h2 id="生态学"><a href="#生态学" class="headerlink" title="生态学"></a>生态学</h2><p>在生态学中，熵表示<strong>生物多样性的指标</strong></p><h2 id="广义的定义"><a href="#广义的定义" class="headerlink" title="广义的定义"></a>广义的定义</h2><p>熵是描述一个系统的<strong>无序程度</strong>的变量；同样的表述还有，熵是系统混乱度的度量，一切自发的不可逆过程都是从<strong>有序</strong>到<strong>无序</strong>的变化过程，向熵增的方向进行</p><p>我们接下来要讨论的<code>信息熵</code> <code>交叉熵</code> <code>相对熵</code> 更多的着眼于信息论的角度，换句话说，更加关注概率和不确定性</p><h1 id="什么是信息熵、交叉熵、相对熵"><a href="#什么是信息熵、交叉熵、相对熵" class="headerlink" title="什么是信息熵、交叉熵、相对熵"></a>什么是信息熵、交叉熵、相对熵</h1><p>可以将对熵的理解从简单到复杂依次分解成三个层次来理解</p><h2 id="如何衡量不确定事物的发生？"><a href="#如何衡量不确定事物的发生？" class="headerlink" title="如何衡量不确定事物的发生？"></a>如何衡量不确定事物的发生？</h2><p>数学是一种工具，使用数学来描述现实中的各种事物是一个数学家本质的工作目标。而现实中不确定性，或者说不太确定是否会发生的事件必须要找到一种<strong>抽象的</strong>、<strong>符号化</strong>和<strong>公式化</strong>的手段去表示。</p><p>比如天气情况，假设可能有【阴、晴、雨、雪】四种情况，使用概率符号表示 $\mathbf P = [p_1,p_2,p_3,p_4]$，接下来自然而然的思考：那么，什么<strong>条件</strong>（情况）会影响这些值呢？</p><p>假设有一下三种描述，或者说条件</p><ul><li>今天是晴天，所以明天可能也是晴天</li><li>天气预报说明天下雨</li><li>9月12日苹果公司举行发布会</li></ul><p>那么这三个描述中，很明显，第二条的信息量更大，因为它可以使得不确定事件发生在 $p_3$ 的<strong>概率更大</strong>。类似的，第三条对判断毫无帮助，信息量为0。<em>注意，信息量不等于信息熵，如果是这样，那么直接用概率来衡量就可以了，不需要在重新定义一个概念</em></p><p><strong>其实信息熵是信息量的期望（均值），它不是针对每条信息，而是针对整个不确定性结果集而言，信息熵越大，事件不确定性就越大。单条信息只能从某种程度上影响结果集概率的分布</strong></p><h2 id="考虑到信息冗余，信息量存储下来究竟需要多大空间？"><a href="#考虑到信息冗余，信息量存储下来究竟需要多大空间？" class="headerlink" title="考虑到信息冗余，信息量存储下来究竟需要多大空间？"></a>考虑到信息冗余，信息量存储下来究竟需要<u>多大空间</u>？</h2><p>我们已经有了 $\mathbf P = [p_1,p_2,p_3,p_4]$ 来表示天气情况，那么用计算机来存储每天的天气，那该如何编码呢？</p><p>常见的做法是，4个不同的信息，只需要2bit就能做到，<code>00</code> <code>01</code> <code>11</code> <code>10</code>，假设我们在南方城市，肯定要把<code>00</code>编码成雨天，这样可以<strong>节省存储空间</strong>，至于为什么能节省存储空间，这就要讨论编码方式。可以简单的理解为，如果一串信息一串<code>0</code>很多，可以<strong>通过编码压缩这一群0来节省空间</strong></p><p>使用一个公式来计算记录<strong>n天数据</strong>需要的<strong>存储空间</strong>：Sn</p>$$S_n = n \times \sum_{i = 1}^4{\left(P_i \times F(P_i) \right) } \tag{2-1}$$<blockquote><p>$P_i$ 表示第i个事件发生的概率；$F(P_i)$ 表示存储空间的存储因子</p></blockquote><p>如何确定这个函数 $F(P_i)$ 的形式？考虑这个函数需要满足条件：<strong>概率大的事件对应小的存储空间，说人话，就是成反比</strong>，你的数学功底不错的话，脑海中第一反应出来满足这个条件最直观是<strong>反比例函数</strong>，说人话， $\frac{1}{P_i}$ 。</p><p>之后我们发现这个公式中有个除法非常讨厌，我们想着去掉它，脑海中第一反应出来的满足这个条件的一定是<strong>取对数</strong>，至于为什么取对数，那说道就很多，取对数是指数的<strong>逆操作</strong>，</p><ul><li>对数操作可以让原本不符合正态分布的模型符合正态分布，比如随着模型自变量的增加，因变量的方差也增大的模型取对数后会更加稳定</li><li>取对数操作可以rescale（原谅我，这里思前想后还是感觉一个英文单词更加生动）其实本质来说都是因为第一点。说人话版本，人不喜欢乘法，对数可以把乘法变加法</li></ul><p>那么我们结束清楚之后，就很容易就可以定义出<br>$$<br>F(P_i) = \log_a ({\frac{1}{P_i}}) \tag{2-2}<br>$$<br> a作为底数，可以取2（处理2bit数据），10（万金油），e（处理正态分布相关的数据）</p><p>结合对信息熵的定义（第一节最后的粗体字）然后把（2-2）带入（2-1），就会发现，哦！看着有点眼熟啊<br>$$<br>H(P) = \sum_i {P(i)log_a {\frac{1}{P(i)}}} = - \sum_i {P(i)log_a {P(i)}} \tag{2-3}<br>$$<br>这这这，就是信息熵的定义式吧？总结就发现，信息熵其实从某种意义上反映了<strong>信息量存储下来需要多少存储空间</strong></p><p>总结为：根据<strong>真实分布</strong>，我们能够找到一个最优策略，以<strong>最小的代价消除系统的不确定性（</strong>比如编码），而<strong>这个代价的大小就是信息熵</strong></p><h2 id="理解基于信息熵的交叉熵和相对熵"><a href="#理解基于信息熵的交叉熵和相对熵" class="headerlink" title="理解基于信息熵的交叉熵和相对熵"></a>理解基于信息熵的交叉熵和相对熵</h2><p>因为是我们用2bit模式存储，为了计算方便，这里取a = 2</p><p>先计算刚刚有关天气问题 $\mathbf P = [p_1,p_2,p_3,p_4]$ ：【阴、晴、雨、雪】的信息熵，假设我们对天气的概率一无所知，那么四种天气的发生概率为<strong>等概率（服从平均分布）</strong>，即 $\mathbf P = [\frac {1}{4},\frac {1}{4},\frac {1}{4},\frac {1}{4}]$ ，带入公式2-3，得到 $H(P) = 2$ ，存储信息需要的空间 $S_n = 2n$ </p><p>继续思考，假设我们考虑天气的城市是一个地处中国南方雨季的城市，那么阴天和雨天的概率从<strong>经验角度（先验概率）</strong>来看大于晴天雪天，把这种分布<strong>记为</strong> $\mathbf Q = [\frac{1}{4},\frac{1}{8},\frac{1}{2},\frac{1}{8}]$，带入公式2-3，信息熵 $H(Q) = 1.75$，存储信息需要的空间 $S_n = 1.75n$ </p><p>直观的来考虑上面不同的两种情况，明显当<strong>事件的不确定性变小</strong>时候，我们可以改变存储策略（00 雨天 01 阴天），再通过编码，节省存储空间。信息熵的大小<strong>就是用来度量这个不确定大小的</strong></p><p>关于编码的方式，这里提一下，<a href="https://zhuanlan.zhihu.com/p/25181781" target="_blank" rel="external">哈夫曼树与哈夫曼编码</a> ，有兴趣的读者可以去研究一下</p><h3 id="交叉熵的由来"><a href="#交叉熵的由来" class="headerlink" title="交叉熵的由来"></a>交叉熵的由来</h3><p>我们把这个问题再扩展一下</p><table><thead><tr><th style="text-align:center">天气【阴、晴、雨、雪】</th><th style="text-align:center">信息熵</th></tr></thead><tbody><tr><td style="text-align:center">$\mathbf P = [\frac{1}{4},\frac{1}{4},\frac{1}{4},\frac{1}{4}]$</td><td style="text-align:center">$H(P) = 2$</td></tr><tr><td style="text-align:center">$\mathbf Q = [\frac{1}{4},\frac{1}{8},\frac{1}{2},\frac{1}{8}]$</td><td style="text-align:center">$H(Q) = 1.75$</td></tr><tr><td style="text-align:center">$\mathbf Z = [\frac{1}{8},\frac{1}{16},\frac{3}{4},\frac{1}{16}]$</td><td style="text-align:center">$H(Z) = \frac{7}{8}+\log_2 {\frac{4}{3}} = 1.29$</td></tr><tr><td style="text-align:center">$\mathbf W = [0,0,1,0]$</td><td style="text-align:center">$H(W) = 0$</td></tr></tbody></table><p>接下来，假定在<strong>确定性更大的概率分布</strong>情况下，用<strong>更不确定的存储策略</strong>来计算，比如使用 $\mathbf P$ 的概率乘上 $\mathbf Q$ 的存储因子，套用公式2-3<br>$$<br>H(\mathbf Q,\mathbf P) = \sum_i {P(i) \log_a {\frac{1}{Q(i)}}} \tag{3-1}<br>$$<br>顾名思义，看公式3-1的形式，就不难发现，这就是所谓的<strong>交叉熵</strong>，计算可得</p><table><thead><tr><th style="text-align:center">交叉熵</th><th style="text-align:center">P</th><th style="text-align:center">Q</th><th style="text-align:center">Z</th><th style="text-align:center">W</th></tr></thead><tbody><tr><td style="text-align:center">P</td><td style="text-align:center">$H(P,P)  = 2$</td><td style="text-align:center">$H(P,Q) = 2.25$</td><td style="text-align:center">$H(P,Z) = \frac{11}{4}+\frac{1}{4}\log_2 {\frac{4}{3}} = 2.85$</td><td style="text-align:center">+inf</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">$H(Q,P) =  2$</td><td style="text-align:center">$H(Q,Q) = 1.75$</td><td style="text-align:center">$H(Q,Z) = \frac{7}{4}+\frac{1}{2}\log_2 {\frac{4}{3}} = 1.96$</td><td style="text-align:center">+inf</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">$H(Z,P) = 2$</td><td style="text-align:center">$H(Z,Q) = 1.375$</td><td style="text-align:center">$H(Z,Z)  = \frac{7}{8}+\log_2 {\frac{4}{3}} = 1.29$</td><td style="text-align:center">+inf</td></tr><tr><td style="text-align:center">W</td><td style="text-align:center">$H(W,P) = 2$</td><td style="text-align:center">$H(W,Q) = 1$</td><td style="text-align:center">$H(W,Z) = \log_2 {\frac{4}{3}} = 0.415$</td><td style="text-align:center">$H(W,W)  = 0$</td></tr></tbody></table><p>上表直观的展现的<strong>交叉熵</strong>的数值表现，PQZW依次<strong>不确定性越来越低</strong>，极端情况的W不确定性为0，即<strong>是确定的</strong></p><p><strong>交叉熵，用来高衡量在给定的真实分布下，使用非真实分布指定的策略消除系统的不确定性所需要付出努力的大小</strong></p><p>总的来说，<strong>我们的目的是：让熵尽可能小，即存储空间小（消除系统的不确定的努力小）。</strong>（不要问为什么想要存储空间小，这都是钱更是效率和时间）</p><p>通过上表我们发现一个规律，为了让熵小，解决方案是：<strong>是用确定性更大的额概率乘以确定性更小的存储因子</strong>，比如不确定性越大的概率分布，如P概率分布，其信息熵越大；<strong>基于同一真实（确定性）分布的情况下</strong>，套用不确定性更大的存储因子，如P的存储因子，得出的交叉熵越大</p><p>在机器学习中，即用测试结果集（样本结果集）的概率乘以训练出来的结果集存储因子，而在不断的训练过程中，我们要做的就是通过不断调整参数，降低这个值，<strong>使得模型更加的稳定，不确定性越来越小</strong>，即突出需要表征的数值的特点（白话文也就是分类的效果更好）</p><h3 id="相对熵的由来"><a href="#相对熵的由来" class="headerlink" title="相对熵的由来"></a>相对熵的由来</h3><p>有了信息熵和交叉熵后，<strong>相对熵是用来衡量两个概率分布之间的差异</strong>，记为 $D(P||Q) = H(P,Q) - H(P)$，也称之为KL散度<br>$$<br>D_{KL}(P||Q) = \sum_i{P(i) \log_a {\frac{P(i)}{Q(i)}}}<br>$$<br>当 $P(i) = Q(i)$ 的时候，该值为0，深度学习过程也是一个降低该值的过程，<strong>该值越低，训练出来的概率Q越接近样本集概率P，即越准确</strong>，或者可以理解为<strong>相对熵一把标尺，用来衡量两个函数是否相似，一样就是0</strong>，当然，这种解释十分牵强，但是更直观</p><blockquote><p>关于底数 $a$ 的选择问题，其实和概率分布的情况是分不开的。比如使用2进制编码，那么所能表示的不同情况的数量，$\sum_{i=0}^N 2^i$，我们知道，指数函数变化率变化很大，不好分析，稳定性差。对数操作可以<strong>乘法变加法，指数放下来</strong>，是十分好用的数学工具（其实是一种变换域的思想，这种思想在整个信息论，统计学中处处可见）</p><p>比如使用 $ln()$ 的时候，对应的分布，其实是<strong>正态分布</strong>，很好理解，正太分布的底数是 $e$</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】10min - 13min&lt;br&gt;【内容简介】使用一个现实中直观的例子详解&lt;strong&gt;信息熵、交叉熵及相对熵&lt;/strong&gt;的核心概念，读完后，希望能帮助你建立起这三个概念的固有直觉，不再疑惑&lt;/p&gt;
&lt;p&gt;要完成题目的最终解释，必须从&lt;strong&gt;熵&lt;/strong&gt;这个神奇的概念开始讲起&lt;/p&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/tags/Machine-Learning/"/>
    
      <category term="Infomation Theory" scheme="https://charlesliuyx.github.io/tags/Infomation-Theory/"/>
    
  </entry>
  
  <entry>
    <title>Dota2机制总结</title>
    <link href="https://charlesliuyx.github.io/2017/09/05/Dota2%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>https://charlesliuyx.github.io/2017/09/05/Dota2机制总结/</id>
    <published>2017-09-06T06:50:56.000Z</published>
    <updated>2017-09-19T05:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】百科类型文章<br>【内容简介】这是一份有关Dota2游戏机制的总结，核心目的是为了方便查阅，<strong>计算公式</strong>。针对人群是对数据和游戏机制有很大兴趣的高玩，从中你可能能了解<strong>如何通过击杀或得更多的经济</strong>，<strong>哪些操作可以躲避技能</strong>等等</p><p>版本信息：更新到7.06f</p><a id="more"></a><h1 id="金钱"><a href="#金钱" class="headerlink" title="金钱"></a>金钱</h1><h2 id="击杀英雄奖励"><a href="#击杀英雄奖励" class="headerlink" title="击杀英雄奖励"></a>击杀英雄奖励</h2><p>获得金钱 = 110 + 连杀奖励 + （被击杀者等级 * 8）</p><p>连杀奖励 = 60 * （连杀数-2）[大于0]</p><h2 id="助攻奖励"><a href="#助攻奖励" class="headerlink" title="助攻奖励"></a>助攻奖励</h2><table><thead><tr><th style="text-align:center">助攻英雄数</th><th>获得金钱</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>[140 + (5 × 被击杀者等级) + (0.0375 × 被击杀者净收入 × 净收入因子) + (100  × 团队净收入之差 / 4000)]</td></tr><tr><td style="text-align:center">2</td><td>[70 + (4 × 被击杀者等级) + (0.0375 × 被击杀者净收入 × 净收入因子) + (75 × 团队净收入之差 / 4000)]</td></tr><tr><td style="text-align:center">3</td><td>[35 + (3 × 被击杀者等级) + (0.0375 × 被击杀者净收入 × 净收入因子) + (50 × 团队净收入之差 / 4000)]</td></tr><tr><td style="text-align:center">4</td><td>[25 + (2 × 被击杀者等级) + (0.03 × 被击杀者净收入 × 净收入因子) + (35 × 团队净收入之差 / 4000)]</td></tr><tr><td style="text-align:center">5</td><td>[20 + (1 × 被击杀者等级) + (0.0225 × 被击杀者净收入 × 净收入因子) + (25 × 团队净收入之差 / 4000)]</td></tr></tbody></table><p>净收入因子 = (敌方队伍净收入 / 友方队伍净收入) - 1，最小值为0，最大值为1</p><p>还需要 × [1.2 - 0.1 × (被击杀者净收入排名 -1)] × [净收入排名因子]</p><h2 id="Roshan"><a href="#Roshan" class="headerlink" title="Roshan"></a>Roshan</h2><p>200 团队奖励</p><p>150 - 400 击杀奖励</p><h2 id="死亡掉钱"><a href="#死亡掉钱" class="headerlink" title="死亡掉钱"></a>死亡掉钱</h2><p>损失不可靠金钱 = 50 + 财产总和 ÷ 40</p><p>5千经济 ➜ 175；1万经济 ➜ 290；2万经济 ➜ 550</p><h1 id="复活"><a href="#复活" class="headerlink" title="复活"></a>复活</h1><h2 id="复活时间"><a href="#复活时间" class="headerlink" title="复活时间"></a>复活时间</h2><ul><li>每级增加2秒</li><li>每到6级的倍数增加10秒</li><li>18级后每级增加4秒</li></ul><h2 id="买活花费"><a href="#买活花费" class="headerlink" title="买活花费"></a>买活花费</h2><p>买活金钱 = 100 + (英雄等级 <em> 英雄等级 </em> 1.5) + (游戏时间(s) * 0.25 )</p><h2 id="放弃比赛"><a href="#放弃比赛" class="headerlink" title="放弃比赛"></a>放弃比赛</h2><p>掉线<strong>超过5分钟后</strong>，所有金钱被队友平分</p><h1 id="物理攻击伤害"><a href="#物理攻击伤害" class="headerlink" title="物理攻击伤害"></a>物理攻击伤害</h1><h2 id="最终攻击伤害"><a href="#最终攻击伤害" class="headerlink" title="最终攻击伤害"></a>最终攻击伤害</h2>$$最终攻击伤害 = \\ \{ [\text {MD} × (1 + \sum \text {PBD}) + \text {FBD}] \times \text {CSM} - \text {BD} \}\\ \times \text {AVM} \times \text {ATM} \times \text {GDM}$$<h3 id="MD-Main-Damage-主要攻击力【白字攻击力】"><a href="#MD-Main-Damage-主要攻击力【白字攻击力】" class="headerlink" title="MD(Main Damage) 主要攻击力【白字攻击力】"></a>MD(Main Damage) 主要攻击力【白字攻击力】</h3><p>主要攻击力 = 基础攻击力 + 主属性</p><p>除此之外，所有加成的攻击力都是【绿字攻击力】</p><h3 id="PBD-Percentage-bonus-damage-百分比攻击力加成"><a href="#PBD-Percentage-bonus-damage-百分比攻击力加成" class="headerlink" title="PBD(Percentage bonus damage) 百分比攻击力加成"></a>PBD(Percentage bonus damage) 百分比攻击力加成</h3><p>这个加成是<strong>加法叠加</strong></p><p>Tips: 圣者遗物可以增加60攻击力，一个出支配带头狼的VS，36%+30% = 66%，60 / 0.66 = 90，也就是说，白字攻击力达到90就等于这个英雄出了一个圣者遗物，相当的可怕。</p><table><thead><tr><th style="text-align:center">技能</th><th style="text-align:center">加成数值</th></tr></thead><tbody><tr><td style="text-align:center">头狼光环</td><td style="text-align:center">30%</td></tr><tr><td style="text-align:center">强化图腾</td><td style="text-align:center">100%/200%/300%/400%</td></tr><tr><td style="text-align:center">野性驱使</td><td style="text-align:center">15%/26%/37%/48%（只影响狼人控制的单位）</td></tr><tr><td style="text-align:center">授予力量</td><td style="text-align:center">20%/30%/40%/50% (天赋 30%/40%/50%/60%)</td></tr><tr><td style="text-align:center">神之力量</td><td style="text-align:center">80%/120%/160% (友军A帐: 75%/100%/125%)</td></tr><tr><td style="text-align:center">复仇光环</td><td style="text-align:center">12%/20%/28%/36% (天赋 32%/40%/48%/56%)</td></tr><tr><td style="text-align:center">祭品光环</td><td style="text-align:center">15%</td></tr></tbody></table><h3 id="FBD-Flat-Bonus-Damage-固定值百分比加成"><a href="#FBD-Flat-Bonus-Damage-固定值百分比加成" class="headerlink" title="FBD(Flat Bonus Damage) 固定值百分比加成"></a>FBD(Flat Bonus Damage) 固定值百分比加成</h3><table><thead><tr><th style="text-align:center">技能</th><th style="text-align:center">加成数值</th></tr></thead><tbody><tr><td style="text-align:center">臂章-邪恶之力</td><td style="text-align:center">31</td></tr><tr><td style="text-align:center">嗜血渴望</td><td style="text-align:center"><strong>最高</strong>攻击力加成/英雄: 16/24/32/40</td></tr><tr><td style="text-align:center">战意</td><td style="text-align:center">最高叠加层数: 5/7/9 每层攻击力加成: 18/24/30</td></tr><tr><td style="text-align:center">极度饥渴</td><td style="text-align:center">60/100/140</td></tr><tr><td style="text-align:center">死亡契约</td><td style="text-align:center">基于目标最大生命值的攻击力加成: 5%/7%/9%</td></tr><tr><td style="text-align:center">精准光环</td><td style="text-align:center">敏捷  20%/26%/32%/38% (天赋26%/32%/38%/44%)</td></tr><tr><td style="text-align:center">星体游魂</td><td style="text-align:center">小兵6/9/12/15 英雄 12/24/36/48 (天赋92/104/116/128)</td></tr><tr><td style="text-align:center">灵动迅捷</td><td style="text-align:center">10/25/40/55/70/85/100 A帐115</td></tr><tr><td style="text-align:center">卡尔-火</td><td style="text-align:center">4/8/12/16/20/24/28 * 3</td></tr><tr><td style="text-align:center">决斗</td><td style="text-align:center">10/14/18 (天赋50/54/58)</td></tr><tr><td style="text-align:center">战斗嚎叫</td><td style="text-align:center">70/100/130</td></tr><tr><td style="text-align:center">月之祝福</td><td style="text-align:center">14/22/30/38</td></tr><tr><td style="text-align:center">嚎叫</td><td style="text-align:center">英雄 10/15/20/25 非英雄  4/6/8/10 夜晚翻倍</td></tr><tr><td style="text-align:center">静电连接</td><td style="text-align:center">每秒偷取 7/14/21/28 (天赋21/28/35/42)</td></tr><tr><td style="text-align:center">支配死灵</td><td style="text-align:center">最大灵魂数: 18/24/30/36 (A帐 22/30/38/46)</td></tr><tr><td style="text-align:center">折光</td><td style="text-align:center"><strong>攻击次数</strong>: 3/4/5/6 (天赋6/7/8/9)<strong>攻击力加成</strong>: 20/40/60/80</td></tr><tr><td style="text-align:center">魔化</td><td style="text-align:center">20/40/60/80</td></tr><tr><td style="text-align:center">长大</td><td style="text-align:center">50/100/150 加主要攻击力</td></tr><tr><td style="text-align:center">衰退光环</td><td style="text-align:center">英雄死亡 30/35/40/45 小兵死亡 5</td></tr></tbody></table><h3 id="CSM-Critical-Strike-Multiplier-致命一击倍数"><a href="#CSM-Critical-Strike-Multiplier-致命一击倍数" class="headerlink" title="CSM(Critical Strike Multiplier) 致命一击倍数"></a>CSM(Critical Strike Multiplier) 致命一击倍数</h3><table><thead><tr><th style="text-align:center">致命一击来源</th><th style="text-align:center">几率%</th><th style="text-align:center">伤害%</th><th style="text-align:center">DPS期望%</th></tr></thead><tbody><tr><td style="text-align:center">头狼 - 致命一击</td><td style="text-align:center">20</td><td style="text-align:center">200</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">血棘 - 致命一击</td><td style="text-align:center">20</td><td style="text-align:center">175</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">酒仙 - 醉拳</td><td style="text-align:center">10/15/20/25</td><td style="text-align:center">230</td><td style="text-align:center">13/19.5/26/32.5</td></tr><tr><td style="text-align:center">混沌一击</td><td style="text-align:center">12</td><td style="text-align:center">125/175/225/275</td><td style="text-align:center">3/9/15/21</td></tr><tr><td style="text-align:center">水晶剑 - 致命一击</td><td style="text-align:center">20</td><td style="text-align:center">175</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">大炮 - 致命一击</td><td style="text-align:center">30</td><td style="text-align:center">235</td><td style="text-align:center">40.5</td></tr><tr><td style="text-align:center">剑舞</td><td style="text-align:center">20/25/30/35</td><td style="text-align:center">200%</td><td style="text-align:center">20/25/30/35</td></tr><tr><td style="text-align:center">狼人 - 变身</td><td style="text-align:center">40</td><td style="text-align:center">160/180/200</td><td style="text-align:center">24/32/40</td></tr><tr><td style="text-align:center">恩赐解脱</td><td style="text-align:center">15</td><td style="text-align:center">230/340/450</td><td style="text-align:center">19.5/36/52.5</td></tr><tr><td style="text-align:center">殊死一搏</td><td style="text-align:center">15</td><td style="text-align:center">英雄 150/200/250/300</td><td style="text-align:center">7.5/15/22.5/30</td></tr><tr><td style="text-align:center">血棘 - 灵魂撕裂</td><td style="text-align:center">100</td><td style="text-align:center">140</td><td style="text-align:center">140</td></tr><tr><td style="text-align:center">忍术</td><td style="text-align:center">100</td><td style="text-align:center">150/175/200/225</td><td style="text-align:center">12/10/8/6 天赋 -5</td></tr><tr><td style="text-align:center">棒击大地</td><td style="text-align:center">100</td><td style="text-align:center">150/175/200/225 天赋+100</td><td style="text-align:center">触发条件</td></tr><tr><td style="text-align:center">暗杀</td><td style="text-align:center">100</td><td style="text-align:center">A帐 280</td><td style="text-align:center">距离内所有敌人</td></tr><tr><td style="text-align:center">海象神拳</td><td style="text-align:center">100</td><td style="text-align:center">350/A帐500</td><td style="text-align:center">冷却 36/24/12</td></tr></tbody></table><p>游戏中出现的<strong>红字代表的是减少前的物理伤害</strong></p><h3 id="BD-Blocked-Damage-被格挡伤害"><a href="#BD-Blocked-Damage-被格挡伤害" class="headerlink" title="BD(Blocked Damage) 被格挡伤害"></a>BD(Blocked Damage) 被格挡伤害</h3><table><thead><tr><th style="text-align:center">伤害格挡来源</th><th style="text-align:center">几率%</th><th style="text-align:center">格挡伤害</th></tr></thead><tbody><tr><td style="text-align:center">圆盾</td><td style="text-align:center">50</td><td style="text-align:center">近战16 远程8</td></tr><tr><td style="text-align:center">穷鬼盾</td><td style="text-align:center">英雄100 非英雄50</td><td style="text-align:center">近战20 远程10</td></tr><tr><td style="text-align:center">先锋盾</td><td style="text-align:center">50</td><td style="text-align:center">近战70 远程35</td></tr><tr><td style="text-align:center">赤红甲 - 坚盾</td><td style="text-align:center">100</td><td style="text-align:center">60</td></tr><tr><td style="text-align:center">海妖外壳</td><td style="text-align:center">100</td><td style="text-align:center">12/24/36/48</td></tr></tbody></table><p>伤害格挡不格挡物理伤害技能，守卫的攻击也不格挡</p><h3 id="AVM-Armor-Value-Multiplier-护甲值倍数"><a href="#AVM-Armor-Value-Multiplier-护甲值倍数" class="headerlink" title="AVM(Armor Value Multiplier) 护甲值倍数"></a>AVM(Armor Value Multiplier) 护甲值倍数</h3><p>见<a href="#Armor"><strong>护甲</strong></a></p><h3 id="ATM-Armor-Type-Multiplier-护甲类型倍数"><a href="#ATM-Armor-Type-Multiplier-护甲类型倍数" class="headerlink" title="ATM(Armor Type Multiplier) 护甲类型倍数"></a>ATM(Armor Type Multiplier) 护甲类型倍数</h3><p>见<a href="#AT"><strong>攻击类型</strong></a>，英雄打英雄100%</p><h3 id="GDM-General-Damage-Multipliers-一般伤害倍数"><a href="#GDM-General-Damage-Multipliers-一般伤害倍数" class="headerlink" title="GDM(General Damage Multipliers) 一般伤害倍数"></a>GDM(General Damage Multipliers) 一般伤害倍数</h3><p>见<a href="#DM"><strong>伤害调整</strong></a><br><a name="AT"></a></p><h2 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h2><p>基础打英雄护甲75%伤害</p><p>穿刺打英雄护甲50%伤害，基础护甲（小兵护甲）150%伤害<br><a name="DM"></a></p><h2 id="伤害调整"><a href="#伤害调整" class="headerlink" title="伤害调整"></a>伤害调整</h2><h3 id="伤害减免和加深"><a href="#伤害减免和加深" class="headerlink" title="伤害减免和加深"></a>伤害减免和加深</h3><p>除了<strong>回光返照，幽灵船，魔法护盾</strong>之外，伤害减免和加深的叠加为<strong>加法叠加</strong></p><table><thead><tr><th style="text-align:center">技能</th><th style="text-align:center">来源</th><th style="text-align:center">数值%</th></tr></thead><tbody><tr><td style="text-align:center">血之狂暴</td><td style="text-align:center">加深接受输出</td><td style="text-align:center">25/30/35/40 远处 减半</td></tr><tr><td style="text-align:center">赎罪</td><td style="text-align:center">加深接受</td><td style="text-align:center">18/24/30/36</td></tr><tr><td style="text-align:center">灵魂猎手</td><td style="text-align:center">加深接受</td><td style="text-align:center">20/30/40/50</td></tr><tr><td style="text-align:center">守卫冲刺</td><td style="text-align:center">加深接受</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">血肉傀儡</td><td style="text-align:center">加深接受</td><td style="text-align:center">20/25/30 200范围内最高</td></tr><tr><td style="text-align:center">回光返照</td><td style="text-align:center">减免接受</td><td style="text-align:center">0 全免 4/5/6 A帐+1</td></tr><tr><td style="text-align:center">刚毛后背</td><td style="text-align:center">减免接受</td><td style="text-align:center">背后 16/24/32/40 侧面 减半</td></tr><tr><td style="text-align:center">奔袭冲撞</td><td style="text-align:center">减免接受</td><td style="text-align:center">A帐 40 持续4秒</td></tr><tr><td style="text-align:center">过载</td><td style="text-align:center">减免接受</td><td style="text-align:center">5/10/15/20</td></tr><tr><td style="text-align:center">幽灵船</td><td style="text-align:center">减免接受</td><td style="text-align:center">40/45/50 持续10秒</td></tr><tr><td style="text-align:center">决斗</td><td style="text-align:center">减免接受</td><td style="text-align:center">A帐 100 持续6/7/8秒</td></tr><tr><td style="text-align:center">魔法护盾</td><td style="text-align:center">减免接受</td><td style="text-align:center">60 1.6/1.9/2.2/2.5</td></tr><tr><td style="text-align:center">钻地</td><td style="text-align:center">减免接受</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">折射</td><td style="text-align:center">减免接受</td><td style="text-align:center">10/14/18/22</td></tr><tr><td style="text-align:center">激怒</td><td style="text-align:center">减免接受</td><td style="text-align:center">80 持续4秒</td></tr><tr><td style="text-align:center">陵卫斗篷</td><td style="text-align:center">减免接受</td><td style="text-align:center">4层 8/12/16/20 冷却6/5/4/3</td></tr><tr><td style="text-align:center">寒冬诅咒</td><td style="text-align:center">减免接受</td><td style="text-align:center">100 3.25/4/4.75</td></tr><tr><td style="text-align:center">战斗饥渴</td><td style="text-align:center">降低输出</td><td style="text-align:center">A帐 30 持续10秒</td></tr><tr><td style="text-align:center">白银之锋</td><td style="text-align:center">降低输出</td><td style="text-align:center">50 持续5秒</td></tr></tbody></table><h3 id="伤害无效化"><a href="#伤害无效化" class="headerlink" title="伤害无效化"></a>伤害无效化</h3><p>伤害实例仍然存在，如果一些与伤害触发相关的事件并且没有低于伤害阈值的伤害，仍然会触发<strong>伤害事件</strong></p><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">无天光盾</td><td style="text-align:center">110/140/170/200 天赋 +300 15s持续时间</td></tr><tr><td style="text-align:center">回光返照</td><td style="text-align:center">3/4/5(A 5/6/7) 伤害转化为治疗</td></tr><tr><td style="text-align:center">凝魂之类</td><td style="text-align:center">5次 大于50点的伤害抵挡120点</td></tr><tr><td style="text-align:center">尖刺外壳</td><td style="text-align:center">2.25s持续时间 无效化每个玩家的<strong>第一次</strong>伤害</td></tr><tr><td style="text-align:center">守护天使</td><td style="text-align:center">6/7/8 (A 8/9/10) 物理伤害无效化</td></tr><tr><td style="text-align:center">虚妄芝诺</td><td style="text-align:center">7/8/9(天赋 +2) 持续时间结束受到被无效化的伤害</td></tr><tr><td style="text-align:center">折光</td><td style="text-align:center">次数 3/4/5/6(天赋 +3) 忽略低于5点的伤害</td></tr><tr><td style="text-align:center">活体护甲</td><td style="text-align:center">所有类型伤害无效化 20/40/60/80 次数 4/5/6/7(天赋 +4) 持续15s  低于5伤害忽略</td></tr><tr><td style="text-align:center">极寒之拥</td><td style="text-align:center">持续时间4s 无效物理伤害</td></tr></tbody></table><h1 id="攻击速度"><a href="#攻击速度" class="headerlink" title="攻击速度"></a>攻击速度</h1><h2 id="基础攻击间隔-BAT"><a href="#基础攻击间隔-BAT" class="headerlink" title="基础攻击间隔 BAT"></a>基础攻击间隔 BAT</h2><p>英雄在没有额外攻速加成的情况下每两次攻击间的<strong>时间间隔</strong></p><h2 id="攻击速度-ISA"><a href="#攻击速度-ISA" class="headerlink" title="攻击速度 ISA"></a>攻击速度 ISA</h2><ul><li>面板中英雄增加的攻击速度</li><li>由装备获得的攻击速度加成</li><li>每个英雄基础100点基础攻速</li><li>由Debuff造成的攻速减低</li></ul><h2 id="攻击速度计算公式"><a href="#攻击速度计算公式" class="headerlink" title="攻击速度计算公式"></a>攻击速度计算公式</h2>$$每秒攻击的次数 = \frac{(100 + IAS) × 0.01} {BAT}$$$$每次攻击的时间 = \frac{1}{每秒攻击的次数}$$<table><thead><tr><th style="text-align:center">攻击速度</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">-80</td><td style="text-align:center">五分之一BAT时间来攻击</td></tr><tr><td style="text-align:center">-75</td><td style="text-align:center">四分之一BAT时间来攻击</td></tr><tr><td style="text-align:center">-66</td><td style="text-align:center">三分之一BAT时间来攻击</td></tr><tr><td style="text-align:center">-50</td><td style="text-align:center">二分之一BAT时间来攻击</td></tr><tr><td style="text-align:center">+00</td><td style="text-align:center">正常状态</td></tr><tr><td style="text-align:center">+100 * n</td><td style="text-align:center">（1+n）倍攻击速度</td></tr></tbody></table><p>根据表格我们可以知道减攻速的技能在基础攻速很高的情况下基本没有什么效果，但是越接近0速度，减速效果越明显</p><h2 id="增加攻击速度技能列表"><a href="#增加攻击速度技能列表" class="headerlink" title="增加攻击速度技能列表"></a>增加攻击速度技能列表</h2><table><thead><tr><th style="text-align:center">技能</th><th style="text-align:center">增加数值</th><th style="text-align:center">持续时间s</th></tr></thead><tbody><tr><td style="text-align:center">魔霭诅咒</td><td style="text-align:center">10/20/30/40</td><td style="text-align:center">4.5</td></tr><tr><td style="text-align:center">雷肤兽 - 暴怒</td><td style="text-align:center">75</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">雷肤兽 - 战鼓光环</td><td style="text-align:center">15</td><td style="text-align:center">光环范围 900</td></tr><tr><td style="text-align:center">天穹守望者 - 磁场</td><td style="text-align:center">50/60/70/80</td><td style="text-align:center">3.5/4.5/5.5/6.5</td></tr><tr><td style="text-align:center">淘汰之刃</td><td style="text-align:center">30</td><td style="text-align:center">6 A帐10 成功淘汰</td></tr><tr><td style="text-align:center">野性之心</td><td style="text-align:center">15/25/35/45</td><td style="text-align:center">光环范围 900</td></tr><tr><td style="text-align:center">扫射</td><td style="text-align:center">130 天赋 +70</td><td style="text-align:center">4/6/8/10</td></tr><tr><td style="text-align:center">熊怪 - 迅捷光环</td><td style="text-align:center">15</td><td style="text-align:center">光环范围 900</td></tr><tr><td style="text-align:center">飓风之力</td><td style="text-align:center">100</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">狂战士之血</td><td style="text-align:center">220/260/300/340</td><td style="text-align:center">剩下10%生命值最高</td></tr><tr><td style="text-align:center">灵动迅捷</td><td style="text-align:center">10/25/40/55/70/85/100/A115</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">卡尔 - 雷</td><td style="text-align:center">2/4/6/8/10/12/14 * 3</td><td style="text-align:center">开关</td></tr><tr><td style="text-align:center">过载</td><td style="text-align:center">40/50/60/70</td><td style="text-align:center">开关</td></tr><tr><td style="text-align:center">强攻</td><td style="text-align:center">65/90/115/140</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">狂暴</td><td style="text-align:center">50/60/70/80</td><td style="text-align:center">3/4/5/6</td></tr><tr><td style="text-align:center">炽魂</td><td style="text-align:center">每层40/55/70/85(天赋 75/90/105/120)</td><td style="text-align:center">10 最高3层</td></tr><tr><td style="text-align:center">德鲁伊 - 狂猛</td><td style="text-align:center">10/20/30/40</td><td style="text-align:center">18/22/26/30</td></tr><tr><td style="text-align:center">跳跃</td><td style="text-align:center">16/32/48/64 (天赋 +100)</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">死灵射手光环</td><td style="text-align:center">5/7/9</td><td style="text-align:center">光环范围 900</td></tr><tr><td style="text-align:center">暗夜猎影</td><td style="text-align:center">45/60/75/90</td><td style="text-align:center">夜晚</td></tr><tr><td style="text-align:center">嗜血术</td><td style="text-align:center">30/40/50/60 (天赋 +40)</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">幻影突袭</td><td style="text-align:center">130</td><td style="text-align:center">4s or 4次攻击</td></tr><tr><td style="text-align:center">战斗专注</td><td style="text-align:center">60/120/180</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">热血战魂</td><td style="text-align:center">15/20/25/30 (105/140/175/210)</td><td style="text-align:center">每次攻击同个目标</td></tr><tr><td style="text-align:center">超强力量</td><td style="text-align:center">400</td><td style="text-align:center">15 or 3/4/5/6次攻击</td></tr><tr><td style="text-align:center">黄泉颤抖</td><td style="text-align:center">64</td><td style="text-align:center">3/4/5/6</td></tr><tr><td style="text-align:center">集中火力</td><td style="text-align:center">500</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">寒冬诅咒</td><td style="text-align:center">70</td><td style="text-align:center">3.25/4/4.75</td></tr></tbody></table><h2 id="降低攻击速度技能"><a href="#降低攻击速度技能" class="headerlink" title="降低攻击速度技能"></a>降低攻击速度技能</h2><p>比较有效果的降低攻速的技能</p><p><code>烈火精灵：80/100/120/140</code> <code>不可侵犯：40/70/100/130</code>，<code>蝮蛇突袭：40/60/80</code> <code>重生：75</code> <code>黄泉颤抖：64</code> <code>小狼-致残：60</code> <code>冰封魔印：30/40/50/60</code> <code>雷霆一击：25/35/45/55</code> <code>原始咆哮：50</code> <code>冰霜新星：20/30/40/50</code> <code>液态火：20/30/40/50</code> <code>石化凝视：50</code> <code>夜魔虚空：50</code> <code>冰眼：45</code> <code>豪猪：10/20/30/40</code> <code>冰火交加：28/32/36/40</code> <code>毒龙法球：10/20/30/40</code> <code>全能光环：10/18/26/34</code></p><h1 id="技能攻击伤害"><a href="#技能攻击伤害" class="headerlink" title="技能攻击伤害"></a>技能攻击伤害</h1><h2 id="技能伤害计算"><a href="#技能伤害计算" class="headerlink" title="技能伤害计算"></a>技能伤害计算</h2><p>魔法伤害受到<a href="#MR">魔法抗性影响</a>，技能伤害可以由智力获得增强</p>$$增强数值 = [初始智力 + (当前等级 - 1) \times 智力成长]  / 14 / 100 + 技能增强天赋$$$$技能最终伤害 = 技能伤害数值 \times (1 + 增强数值) \times \\ \prod_{i=1}^n{(1 - 魔法抗性增加_i)} \times\prod_{i=1}^n{(1 + 魔法抗性降低_i)}$$<h3 id="技能增强天赋"><a href="#技能增强天赋" class="headerlink" title="技能增强天赋"></a>技能增强天赋</h3><p><code>远古冰魄10：8%</code> <code>蝙蝠骑士15：5%</code> <code>人马20：10%</code> <code>死亡先知10：5%</code> <code>干扰者20：10%</code> <code>大地之灵20：15%</code> <code>灰烬之灵10：8%</code> <code>矮人直升机10：6%</code> <code>杰奇洛10：8%</code> <code>拉西克20：5%</code> <code>莉娜20：6%</code> <code>莱恩20：8%</code> <code>马格纳斯10：15%</code> <code>米拉娜15：5%</code> <code>食人魔魔法师25：15%</code> <code>殁境神蚀者25：8%</code> <code>凤凰20：8%</code> <code>帕克20：10%</code> <code>拉比克20：8%</code> <code>暗影恶魔15：8%</code> <code>影魔15：6%</code> <code>风暴之灵25：10%</code> <code>伐木机20：5%</code> <code>修补匠15：4%</code> <code>孽主15：12%</code> <code>维萨吉25：20%</code> <code>风行者20：15%</code></p><h2 id="技能伤害类型"><a href="#技能伤害类型" class="headerlink" title="技能伤害类型"></a>技能伤害类型</h2><p>分为：魔法伤害，物理伤害，纯粹伤害</p><p>大部分伤害为魔法伤害</p><h3 id="物理伤害技能"><a href="#物理伤害技能" class="headerlink" title="物理伤害技能"></a>物理伤害技能</h3><p><code>炼金术士：酸性喷雾</code> <code>炼金术士：不稳定化合物</code> <code>敌法师：法力损毁</code> <code>斧王：反击螺旋</code> <code>兽王：野性飞斧</code> <code>赏金猎人：暗影步</code> <code>钢背兽：针刺扫射</code> <code>人马：反击</code> <code>克林克兹：灼热之箭</code> <code>戴泽：剧毒之触</code> <code>戴泽：暗影波</code> <code>死亡先知：驱使恶灵</code> <code>主宰：无敌斩</code> <code>昆卡：潮汐使者</code> <code>拉西克：恶魔的赦令</code> <code>噬魂鬼：盛宴</code> <code>剃刀：风暴之眼</code> <code>斯拉达：鱼人碎击</code> <code>斯拉达：深海重击</code> <code>狙击手：爆头</code> <code>工程师：感应地雷</code> <code>工程师：爆破起飞</code> <code>潮汐猎人：锚机</code> <code>熊战士：怒意狂击</code> <code>冥界亚龙：幽冥剧毒</code> <code>编织者：虫群</code></p><h3 id="纯粹伤害技能"><a href="#纯粹伤害技能" class="headerlink" title="纯粹伤害技能"></a>纯粹伤害技能</h3><p><code>祸乱之源：蚀脑</code> <code>祸乱之源：噩梦</code> <code>刃甲：反弹伤害</code> <code>嗜血狂魔：血之祭祀</code> <code>嗜血狂魔：割裂</code> <code>陈：忠诚考验</code> <code>死亡先知：吸魂巫术</code> <code>末日使者：末日</code> <code>魅惑魔女：推进</code> <code>谜团：午夜凋零</code> <code>祈求者：电磁脉冲</code> <code>祈求者：阳炎冲击</code> <code>莉娜：神灭斩A帐</code> <code>美杜莎：石化后秘术异蛇</code> <code>司夜刺客：尖刺外壳</code> <code>全能骑士：洗礼</code> <code>殁境神蚀者：奥术天球</code> <code>帕吉：肉狗</code> <code>痛苦女王：超声波冲击</code> <code>沉默术士：智慧之刃</code> <code>幽鬼：荒芜</code> <code>圣堂刺客：灵能之刃</code> <code>伐木机：锯齿飞轮</code> <code>伐木机：伐木锯链</code> <code>伐木机：带树木死亡旋风</code> <code>修补匠：激光</code> <code>骨灰</code><br><a name="Armor"></a></p><h1 id="护甲"><a href="#护甲" class="headerlink" title="护甲"></a>护甲</h1><h2 id="白字护甲"><a href="#白字护甲" class="headerlink" title="白字护甲"></a>白字护甲</h2><p>$$<br>敏捷 = 基础敏捷 + (等级 - 1) * 敏捷成长<br>$$</p><p>$$<br>白字护甲 = 基础护甲 + ( \frac{敏捷}{7})<br>$$</p><h2 id="护甲值倍数"><a href="#护甲值倍数" class="headerlink" title="护甲值倍数"></a>护甲值倍数</h2><p>$$<br>护甲值倍数 = 1 - \frac{0.06 \times 护甲值}{1 + 0.06 \times |护甲值| }<br>$$</p><h2 id="护甲值倍数倍数和护甲值的相关曲线"><a href="#护甲值倍数倍数和护甲值的相关曲线" class="headerlink" title="护甲值倍数倍数和护甲值的相关曲线"></a>护甲值倍数倍数和护甲值的相关曲线</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/05/Dota2机制总结/Dota_2_armor_debuff_efficiency.png" alt="相关曲线" title="">                </div>                <div class="image-caption">相关曲线</div>            </figure><p>纵坐标是护甲值倍数，横坐标是现在英雄的护甲，不同颜色的线是此时减少的护甲（越上面的线减的越多）</p><h2 id="有效生命值-（EHP）"><a href="#有效生命值-（EHP）" class="headerlink" title="有效生命值 （EHP）"></a>有效生命值 （EHP）</h2><p>有效生命值 = 总生命值 ÷ 护甲值倍数</p>$$实时有效物理生命值 = 当前生命值 \div (1 - \frac{0.06 \times 当前总护甲值}{1 + 0.06 \times |当前总护甲值| })$$$$实时有效魔法生命值 = 当前生命值 \div (0.75 \times (1 - 装备提供抗性_1) \times \ldots \times (1 - 装备提供抗性_n))$$<h2 id="护甲调整"><a href="#护甲调整" class="headerlink" title="护甲调整"></a>护甲调整</h2><h3 id="增加护甲的技能"><a href="#增加护甲的技能" class="headerlink" title="增加护甲的技能"></a>增加护甲的技能</h3><table><thead><tr><th style="text-align:center">技能</th><th style="text-align:center">加成数值</th><th style="text-align:center">持续时间s</th></tr></thead><tbody><tr><td style="text-align:center">黑龙 - 龙肤光环</td><td style="text-align:center">3</td><td style="text-align:center">光环范围 900</td></tr><tr><td style="text-align:center">狂战士怒吼</td><td style="text-align:center">40</td><td style="text-align:center">2/2.4/2.8/3.2</td></tr><tr><td style="text-align:center">编织</td><td style="text-align:center">0.75/1.0/1.25 每秒  18/24/30</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">龙族血统</td><td style="text-align:center">3/6/9/12(天赋 翻倍)</td><td style="text-align:center">永久</td></tr><tr><td style="text-align:center">霜冻护甲</td><td style="text-align:center">3/5/7/9</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">战斗嚎叫</td><td style="text-align:center">10/15/20</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">变形术</td><td style="text-align:center">4/6/8</td><td style="text-align:center">变形状态</td></tr><tr><td style="text-align:center">寒冰盔甲</td><td style="text-align:center">8</td><td style="text-align:center">45</td></tr><tr><td style="text-align:center">战吼</td><td style="text-align:center">5/10/15/20</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">活性护甲</td><td style="text-align:center">5/10/15/20 每层 1/1.2/1.4/1.6</td><td style="text-align:center">10/13/16/19</td></tr><tr><td style="text-align:center">崎岖外表</td><td style="text-align:center">3/4/5/6</td><td style="text-align:center">永久</td></tr><tr><td style="text-align:center">巨魔 - 狂战士之怒</td><td style="text-align:center">6</td><td style="text-align:center">切换</td></tr></tbody></table><h3 id="减低护甲的技能"><a href="#减低护甲的技能" class="headerlink" title="减低护甲的技能"></a>减低护甲的技能</h3><table><thead><tr><th style="text-align:center">技能</th><th style="text-align:center">降低数值</th><th style="text-align:center">持续时间s</th></tr></thead><tbody><tr><td style="text-align:center">酸性喷雾</td><td style="text-align:center">4/5/6/7 (天赋 +4)</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">远古 - 亵渎</td><td style="text-align:center">50%</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">粘稠鼻液</td><td style="text-align:center">1/1.4/1.8/2.2 最高层数4(8)</td><td style="text-align:center">英雄5 小兵10</td></tr><tr><td style="text-align:center">实相裂隙</td><td style="text-align:center">3/4/5/6</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">编织</td><td style="text-align:center">0.75/1/1.25每秒 (18/24/30)</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">自然秩序</td><td style="text-align:center">基础护甲：40%/60%/80%/100%</td><td style="text-align:center">光环范围 275</td></tr><tr><td style="text-align:center">火人 - 攻击</td><td style="text-align:center">每次1点 上限10</td><td style="text-align:center">5 击中刷新时间</td></tr><tr><td style="text-align:center">激流</td><td style="text-align:center">2/3/4/5</td><td style="text-align:center">8 范围 320</td></tr><tr><td style="text-align:center">风暴之眼</td><td style="text-align:center">0.7/0.6/0.5 (天赋 -0.1) 打击1次1点</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">魔王降临</td><td style="text-align:center">3/4/5/6</td><td style="text-align:center">光环范围 900</td></tr><tr><td style="text-align:center">侵蚀雾霭</td><td style="text-align:center">10/15/20</td><td style="text-align:center">18</td></tr><tr><td style="text-align:center">隐匿</td><td style="text-align:center">2/4/6/8</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">巨浪</td><td style="text-align:center">3/4/5/6 (天赋 +5)</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">死亡旋风</td><td style="text-align:center">敏捷损失 * 0.14</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">恐怖波动</td><td style="text-align:center">3/4/5/6 1400距离 300范围</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">虫群</td><td style="text-align:center">1.4/1.25/1.1/0.95 攻击一次1点</td><td style="text-align:center">16</td></tr></tbody></table><h3 id="护甲相关装备"><a href="#护甲相关装备" class="headerlink" title="护甲相关装备"></a>护甲相关装备</h3><p>强袭 +5 玄冥盾牌系列 +2  勋章 +7 天鹰 +2 炎阳纹章 +10 祭品 +4 </p><p>黯灭 -7 勋章 -7 炎阳纹章 -10 强袭 -5 枯萎之石 -2 疯脸 -5</p><h1 id="闪避"><a href="#闪避" class="headerlink" title="闪避"></a>闪避</h1><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>闪避与致盲都会在<strong>攻击完成</strong>（弹道击中）时有一定几率触发</p><h2 id="叠加与计算"><a href="#叠加与计算" class="headerlink" title="叠加与计算"></a>叠加与计算</h2><p>多个闪避来源<strong>乘法叠加</strong></p><h3 id="上下坡落空几率"><a href="#上下坡落空几率" class="headerlink" title="上下坡落空几率"></a>上下坡落空几率</h3><p>如果攻击者处于比目标更低的位置时，远程攻击会有25%的几率落空。</p><p>攻击者和目标之间的地形的高低差异实在<strong>击中目标时决定的</strong>，中路对线过程中，可以使用弹道飞行过程位移来保持和目标的同样地形高度保证必中</p><p><strong>飞行单位</strong>无上下坡落空几率</p><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>$\prod_{i=0}^n$ 的含义是把i=0到n所有的项相乘<br>$$落空几率 = \prod_{i=0}^n (1 - 闪避来源_i) \times  \prod_{j=0}^n (1 - 致盲来源_j) \times 上下坡落空几率$$$$命中几率 = 1 - \prod_{i = 0}^n{(1 - 必中/克敌先机来源_i)}$$$$最终命中几率 = 1 - 落空几率 \times (1 - 命中几率)$$$$最终落空几率 = 落空几率 \times (1 - 命中几率)$$<br>公式只是为了程序数值计算使用，是需要记住：<strong>每一次攻击要绕过所有的闪避成功命中，只有当所有的闪避都失败了，这次攻击才可以造成伤害</strong>。所以说，出很多个闪避装备，在一定程度上对物理核心非常克制，这时候物理核心必须出金箍棒</p><h2 id="闪避来源"><a href="#闪避来源" class="headerlink" title="闪避来源"></a>闪避来源</h2><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">闪避几率%</th></tr></thead><tbody><tr><td style="text-align:center">敌法师 - 20级右天赋</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">磁场</td><td style="text-align:center">100 3.5/4.5/5.5/6.5s</td></tr><tr><td style="text-align:center">醉拳</td><td style="text-align:center">10/15/20/25 一段时间的100%闪避</td></tr><tr><td style="text-align:center">赏金猎人 - 25级右天赋</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">蝴蝶</td><td style="text-align:center">35</td></tr><tr><td style="text-align:center">人马 - 15级右天赋</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">克林克兹 - 20级右天赋</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">虚空 - 25级右天赋</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">黑暗贤者 - 10级右天赋</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">天堂之戟</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">噬魂鬼 - 20级右天赋</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">狼人 - 20级右天赋</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">美杜莎 - 15级左天赋</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">米波 - 20级右天赋</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">大圣 - 10级左天赋</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">模糊</td><td style="text-align:center">20/30/40/50</td></tr><tr><td style="text-align:center">猴子 - 20级左天赋</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">炎阳纹章</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">炎阳纹章- 队友使用 - 日耀</td><td style="text-align:center">20 7s</td></tr><tr><td style="text-align:center">斯温 - 20级左天赋</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">闪避护肤</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">圣堂刺客 - 15级左天赋</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">风行</td><td style="text-align:center">100 3/4/5/6a</td></tr></tbody></table><h3 id="致盲来源"><a href="#致盲来源" class="headerlink" title="致盲来源"></a>致盲来源</h3><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">落空几率%</th></tr></thead><tbody><tr><td style="text-align:center">醉酒云雾</td><td style="text-align:center">70 4s</td></tr><tr><td style="text-align:center">麻痹之咬</td><td style="text-align:center">30/40/50/60 2s</td></tr><tr><td style="text-align:center">致盲之光</td><td style="text-align:center">80 3/4/5s</td></tr><tr><td style="text-align:center">伤残恐惧</td><td style="text-align:center">白天10 3s 夜晚50 5/6/7/8s</td></tr><tr><td style="text-align:center">辉耀 - 辉耀灼烧</td><td style="text-align:center">17</td></tr><tr><td style="text-align:center">烟雾</td><td style="text-align:center">40/50/60/70 6s</td></tr><tr><td style="text-align:center">激光</td><td style="text-align:center">100 3/3.5/4/4.5s 小兵 6s</td></tr><tr><td style="text-align:center">近战旋风飞斧</td><td style="text-align:center">60 4/5/6/7s</td></tr></tbody></table><h3 id="克敌机先来源"><a href="#克敌机先来源" class="headerlink" title="克敌机先来源"></a>克敌机先来源</h3><p>为一种<u>攻击特效</u>，防止该次攻击落空，用来反制闪避，致盲，以及远程单位上下坡的25%几率落空，也能够防止近战攻击由于目标在攻击之前超过了350距离而落空</p><p>但是攻击弹道依旧可以<strong>躲避</strong></p><p>对建筑物无效</p><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">备注 不会落空为100%</th></tr></thead><tbody><tr><td style="text-align:center">强化图腾</td><td style="text-align:center">带有Buff的一次攻击不会落空</td></tr><tr><td style="text-align:center">棒击大地</td><td style="text-align:center">不会落空的即时攻击</td></tr><tr><td style="text-align:center">金箍棒</td><td style="text-align:center">每次攻击带有克敌先机</td></tr><tr><td style="text-align:center">复仇</td><td style="text-align:center">破影一击不会落空</td></tr><tr><td style="text-align:center">窒息之刃</td><td style="text-align:center">不会落空的即时攻击</td></tr><tr><td style="text-align:center">白银之锋 - 暗影步</td><td style="text-align:center">破影一击不会落空</td></tr><tr><td style="text-align:center">暗杀</td><td style="text-align:center">需要A帐</td></tr><tr><td style="text-align:center">自然庇护</td><td style="text-align:center">破影一击不会落空</td></tr><tr><td style="text-align:center">海象神拳！</td><td style="text-align:center">不会落空</td></tr><tr><td style="text-align:center">死亡守卫</td><td style="text-align:center">需要A帐 不会落空</td></tr></tbody></table><h3 id="必中来源"><a href="#必中来源" class="headerlink" title="必中来源"></a>必中来源</h3><p>必中防止一个单位受到的任何攻击落空</p><p>血棘的灵魂撕裂，岗哨守卫，炎阳纹章给敌方使用提供35%的必中效果</p><h1 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h1><h2 id="叠加"><a href="#叠加" class="headerlink" title="叠加"></a>叠加</h2><p>相似的装备提供的移动速度不叠加，除了风帐</p><p>多个鞋类物品不叠加</p><p>夜叉 散夜对剑 幻影斧不叠加</p><p>多个战鼓或风灵之纹不叠加</p><p><u>风灵之纹和战鼓鞋类物品叠加</u></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>移动速度 = （基础移动速度 + 具体移动速度加成） * （1 + 百分比移动速度加成和减速的和）<br><a name="MR"></a></p><h1 id="魔法抗性"><a href="#魔法抗性" class="headerlink" title="魔法抗性"></a>魔法抗性</h1><p>魔法抗性除了米波35%，维萨吉10%魔法抗性外，其他英雄都为25%基础魔法抗性</p><p>魔法抗性乘法叠加，不同的提高魔法抗性的装备可以叠加</p><h2 id="魔法抗性加成来源"><a href="#魔法抗性加成来源" class="headerlink" title="魔法抗性加成来源"></a>魔法抗性加成来源</h2><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">加成数值%及备注</th></tr></thead><tbody><tr><td style="text-align:center">法术护盾</td><td style="text-align:center">26/34/42/50</td></tr><tr><td style="text-align:center">小马or小熊怪光环</td><td style="text-align:center">英雄5 非英雄20 可叠加</td></tr><tr><td style="text-align:center">魔抗斗篷</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">微光披风</td><td style="text-align:center">15 被动</td></tr><tr><td style="text-align:center">微光披风 - 微光</td><td style="text-align:center">45 5s 0.6s渐隐时间</td></tr><tr><td style="text-align:center">挑战头巾</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">狂战士之血</td><td style="text-align:center">20/30/40/50 最大10%生命值</td></tr><tr><td style="text-align:center">洞察烟斗</td><td style="text-align:center">30 被动</td></tr><tr><td style="text-align:center">洞察烟斗光环</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">腐肉堆积</td><td style="text-align:center">6/8/10/12</td></tr><tr><td style="text-align:center">失效力场</td><td style="text-align:center">10/14/18/22</td></tr><tr><td style="text-align:center">腐蚀皮肤</td><td style="text-align:center">10/15/20/25</td></tr></tbody></table><h2 id="魔法抗性减少来源"><a href="#魔法抗性减少来源" class="headerlink" title="魔法抗性减少来源"></a>魔法抗性减少来源</h2><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">减少数值%</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">冰霜漩涡</td><td style="text-align:center">15/20/25/30</td><td style="text-align:center">16s 0.5s粘滞时间</td></tr><tr><td style="text-align:center">自然秩序</td><td style="text-align:center">40/60/80/100</td><td style="text-align:center">光环范围350 1s粘滞时间</td></tr><tr><td style="text-align:center">虚化冲击</td><td style="text-align:center">40</td><td style="text-align:center">敌方3s 友方4s</td></tr><tr><td style="text-align:center">幽灵形态</td><td style="text-align:center">40</td><td style="text-align:center">4s</td></tr><tr><td style="text-align:center">幽魂护罩</td><td style="text-align:center">20</td><td style="text-align:center">3/3.5/4/4.5</td></tr><tr><td style="text-align:center">衰老</td><td style="text-align:center">30/40/50/60</td><td style="text-align:center">3.5</td></tr><tr><td style="text-align:center">上古封印</td><td style="text-align:center">30/35/40/45</td><td style="text-align:center">3/4/5/6</td></tr><tr><td style="text-align:center">纷争面纱</td><td style="text-align:center">25</td><td style="text-align:center">16</td></tr></tbody></table><h2 id="魔法抗性100-来源"><a href="#魔法抗性100-来源" class="headerlink" title="魔法抗性100%来源"></a>魔法抗性100%来源</h2><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">黑皇杖</td><td style="text-align:center">10/9/8/7/6/5</td></tr><tr><td style="text-align:center">牺牲</td><td style="text-align:center">跳跃时间or持续5s</td></tr><tr><td style="text-align:center">剑刃风暴</td><td style="text-align:center">5s</td></tr><tr><td style="text-align:center">狂暴</td><td style="text-align:center">3/4/5/6 (天赋+1s)</td></tr><tr><td style="text-align:center">石化凝视</td><td style="text-align:center">3s 天赋5s</td></tr><tr><td style="text-align:center">驱逐</td><td style="text-align:center">4/5/6/7</td></tr><tr><td style="text-align:center">命运赦令</td><td style="text-align:center">3/3.5/4/4.5</td></tr></tbody></table><h2 id="魔法吸收护盾"><a href="#魔法吸收护盾" class="headerlink" title="魔法吸收护盾"></a>魔法吸收护盾</h2><p>魔法吸收护盾计算是计算魔抗后的吸收数值，<strong>魔抗越高，护盾效果越好</strong></p><p>任何类型魔法护盾<strong>无法叠加</strong>，同时吸收伤害</p><table><thead><tr><th style="text-align:center">技能或物品名称</th><th style="text-align:center">吸收数值</th></tr></thead><tbody><tr><td style="text-align:center">烈火罩</td><td style="text-align:center">50/200/350/500 （天赋 +500）</td></tr><tr><td style="text-align:center">挑战头巾 - 绝缘</td><td style="text-align:center">325 持续12s</td></tr><tr><td style="text-align:center">洞察烟斗 - 法术护盾</td><td style="text-align:center">400 持续12s</td></tr></tbody></table><h1 id="物品被动效果叠加"><a href="#物品被动效果叠加" class="headerlink" title="物品被动效果叠加"></a>物品被动效果叠加</h1><h2 id="独立叠加"><a href="#独立叠加" class="headerlink" title="独立叠加"></a>独立叠加</h2><ul><li>攻击力</li><li>属性加成</li><li>魔法值/生命值</li><li>生命恢复速率/魔法恢复速率（基础速率 * 加成倍数）</li><li>攻击速度加成</li><li>护甲加成</li><li>分裂区域</li><li>移动速度加成</li></ul><h2 id="乘法叠加"><a href="#乘法叠加" class="headerlink" title="乘法叠加"></a>乘法叠加</h2><p>出现边缘递减效应<br>$$<br>加成 = 1 - (1-x) \times (1-y) \times (1-z) \times \ldots<br>$$<br>其中 $x y z$ 都表示一个百分比</p><p>魔法抗性乘法叠加</p><ul><li>一个100点魔法伤害的技能</li><li>英雄本身25%魔法抗性，伤害变为 100 * （1 - 25%） = 75</li><li>再装备挑战头巾，再降低30%，伤害变为 75 * （1 - 30%） = 52.5</li></ul><h1 id="躲避"><a href="#躲避" class="headerlink" title="躲避"></a>躲避</h1><p>躲避是一种躲避弹道的行为，更确切的说，是使弹道完全失去跟踪目标能力的行为。白话文就是：<strong>秀操作，骚</strong></p><h2 id="躲避技能的方式"><a href="#躲避技能的方式" class="headerlink" title="躲避技能的方式"></a>躲避技能的方式</h2><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>以下技能在施法时能躲避弹道</p><p><code>炼金术士：化学狂暴</code> <code>酒仙：元素分离</code> <code>混沌骑士：混沌之军</code> <code>噬魂鬼：感染``幻影斧：镜像</code> <code>变体精灵：波浪形态</code> <code>娜迦海妖：镜像</code> <code>幻影长矛手：神行百变``凤凰：超新星</code> <code>帕克：相位转移</code> <code>力丸：绝杀秘技</code> <code>风暴之灵：球状闪电</code></p><h3 id="传送"><a href="#传送" class="headerlink" title="传送"></a>传送</h3><p>所有的真闪烁都能<strong>躲避弹道</strong>，躲避发生在使用技能移动时</p><p><code>敌法师：闪烁</code> <code>闪烁匕首：闪烁</code> <code>远行鞋：传送</code>  <code>艾欧：传送</code>(只有艾欧传送过去时可以躲避) <code>先知：传送</code> <code>帕克：灵动之翼</code> <code>痛苦女王：闪烁</code> <code>熊灵：回归</code> <code>回城卷轴：传送</code> <code>孽主：黑暗之门</code> <code>编织者：时光倒流</code> <code>陈：忠诚考验</code> <code>光之守卫：召回</code> <code>变体精灵：替换复制品</code></p><h3 id="隐身"><a href="#隐身" class="headerlink" title="隐身"></a>隐身</h3><p>所有能获得隐身状态的技能技能都能躲避弹道，除非敌人的在弹道到达之前使用了反隐，但是必须要注意不同技能的渐隐时间</p><h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>变为临时性的隐藏不能躲避弹道。</p><p>躲避与变为隐藏无关，而是与技能本身有关。这意味着隐藏技能不一定都能躲避弹道，</p><p>但是，利用合适的时机，可<strong>阻止弹道或一般技能，击中施法者或目标</strong>。</p><p>隐藏来源有一下技能</p><p><code>酒仙：元素分离</code> <code>混沌骑士：混沌之军</code> <code>大地之灵：残炎魔咒</code> <code>噬魂鬼：吸收</code> <code>幻影斧：镜像</code> <code>娜迦海妖：镜像</code> <code>殁境神蚀者：星体禁锢</code> <code>幻影长矛手：神行百变</code> <code>凤凰：超新星</code> <code>帕克：相位转移</code> <code>力丸：绝杀秘技</code> <code>暗影恶魔：崩裂禁锢</code> <code>巨牙海民：雪球</code></p><h3 id="无敌"><a href="#无敌" class="headerlink" title="无敌"></a>无敌</h3><p>变为无敌不能躲避弹道，但是可以在击中时减轻或使其效果无效。</p><p><strong>攻击伤害和技能伤害会被忽略</strong>。有一些技能<strong>可以影响无敌单位</strong>。</p><p>无敌来源</p><p><code>祸乱之源：噩梦</code> <code>酒仙：元素分离</code> <code>混沌骑士：混沌之军</code> <code>大地之灵：残岩魔咒</code> <code>灰烬之灵：无影拳</code> <code>灰烬之灵：激活残焰</code> <code>风帐：龙卷风</code> <code>虚空假面：时间漫游</code> <code>佣兽：石像形态</code> <code>祈求者：强袭飓风</code> <code>主宰：无敌斩</code> <code>噬魂鬼：吸收</code> <code>噬魂鬼：感染</code> <code>幻影斧：镜像</code> <code>变体精灵：波浪形态</code> <code>娜迦海妖：镜像</code> <code>娜迦海妖：海妖之歌</code> <code>殁境神蚀者：星体禁锢</code> <code>幻影长矛手：神行百变</code> <code>凤凰：超新星</code> <code>帕克：相位转移</code> <code>力丸：绝杀秘技</code> <code>暗影恶魔：崩裂禁锢</code> <code>狂风：龙卷风</code> <code>风暴之灵：球状闪电</code> <code>巨牙海民：雪球</code></p><h2 id="可以被躲避的弹道"><a href="#可以被躲避的弹道" class="headerlink" title="可以被躲避的弹道"></a>可以被躲避的弹道</h2><p>任何单位和英雄的所有物理攻击的弹道都可以躲避</p><h3 id="可以被躲避的技能"><a href="#可以被躲避的技能" class="headerlink" title="可以被躲避的技能"></a>可以被躲避的技能</h3><p><code>亚巴顿：迷雾缠绕</code> <code>赏金猎人：投掷飞镖</code> <code>酒仙：醉酒云雾</code> <code>钢背兽：粘稠鼻涕</code> <code>育母蜘蛛：孵化蜘蛛</code> <code>混沌骑士：混乱之箭</code> <code>陈：赎罪</code> <code>戴泽：剧毒之触</code> <code>龙骑士：神龙摆尾</code> <code>大地：投掷巨石</code> <code>撼地者：回音击</code> <code>虚灵之刃：虚化冲击</code> <code>变体精灵：变体攻击</code> <code>泥土傀儡：投石</code> <code>娜迦海妖：诱捕</code> <code>食人魔魔法师：引燃</code> <code>神谕者：气运之末</code> <code>幻影刺客：窒息之刃</code> <code>幻影长矛手：灵魂之矛</code> <code>痛苦女王：暗影突袭</code> <code>阿托斯：致残</code> <code>天怒法师：震荡光弹</code> <code>狙击手：暗杀</code> <code>斯温：风暴之拳</code> <code>潮汐猎人：巨浪</code> <code>修补匠：导热飞弹</code> <code>复仇之魂：魔法箭</code> <code>冥界亚龙：蝮蛇突袭</code> <code>维萨吉：灵魂超度</code> <code>风行者：束缚击</code> <code>寒冬飞龙：碎裂冲击</code> <code>冥魂大帝：冥火暴击</code></p><h3 id="不可以被躲避的技能"><a href="#不可以被躲避的技能" class="headerlink" title="不可以被躲避的技能"></a>不可以被躲避的技能</h3><p><code>炼金术士：不稳定化合物</code> <code>天穹守望者：闪光幽魂</code> <code>爱人直升机：追踪导弹</code> <code>哈斯卡：牺牲</code> <code>拉西克：闪电风暴</code> <code>巫妖：连环霜冻</code> <code>莉娜：神灭斩</code> <code>莱恩：死亡一指</code> <code>美杜莎：秘术异蛇</code> <code>米拉娜：流星风暴</code> <code>瘟疫法师：死亡脉冲</code> <code>痛苦女王：痛苦尖叫</code> <code>拉比克：技能窃取</code> <code>天怒法师：奥法鹰隼</code> <code>幽鬼：幽鬼之刃</code> <code>小小：投掷</code> <code>树精卫士：寄生种子</code> <code>巨牙海民：雪球</code> <code>寒冬飞龙：碎裂冲击弹射</code> <code>巫医：麻痹药剂</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】百科类型文章&lt;br&gt;【内容简介】这是一份有关Dota2游戏机制的总结，核心目的是为了方便查阅，&lt;strong&gt;计算公式&lt;/strong&gt;。针对人群是对数据和游戏机制有很大兴趣的高玩，从中你可能能了解&lt;strong&gt;如何通过击杀或得更多的经济&lt;/strong&gt;，&lt;strong&gt;哪些操作可以躲避技能&lt;/strong&gt;等等&lt;/p&gt;
&lt;p&gt;版本信息：更新到7.06f&lt;/p&gt;
    
    </summary>
    
      <category term="Dota2" scheme="https://charlesliuyx.github.io/categories/Dota2/"/>
    
    
      <category term="Dota2" scheme="https://charlesliuyx.github.io/tags/Dota2/"/>
    
      <category term="Data Analysis" scheme="https://charlesliuyx.github.io/tags/Data-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>【直观详解】Logistic Regression</title>
    <link href="https://charlesliuyx.github.io/2017/09/04/LogisticRegression%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://charlesliuyx.github.io/2017/09/04/LogisticRegression学习笔记/</id>
    <published>2017-09-04T07:21:50.000Z</published>
    <updated>2017-09-21T06:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】17min - 22min<br>【内容简介】从不同角度解释<strong>为何使用Logistic回归模型</strong>，解读模型的<strong>现实意义</strong>，详细解读<strong>为何使用</strong>以及<strong>什么是</strong>交叉熵损失函数。并详细梳理符号表达，对公式不再恐惧</p><a id="more"></a><h2 id="什么是【回归（Regression）】"><a href="#什么是【回归（Regression）】" class="headerlink" title="什么是【回归（Regression）】"></a>什么是【回归（Regression）】</h2><p>回归（Regression）是一项模拟技术，用来从<strong>一个或多个解释变量</strong>中<u>预测</u><strong>输出变量的值</strong></p><h2 id="什么是及为什么【Logistic-Regression】"><a href="#什么是及为什么【Logistic-Regression】" class="headerlink" title="什么是及为什么【Logistic Regression】"></a>什么是及为什么【Logistic Regression】</h2><p>回归（Regression）是用来预测的，比如给你一组虫子的腿长和翅膀长数据，让你判断虫子是A类虫还是B类虫。</p><p><strong>逻辑回归</strong>则是用来预测<strong>二进制</strong>输出变量取值（如：<strong>是/不是</strong>）的预测技术</p><blockquote><p>即输出变量只有<strong>两个值</strong>得预测技术</p></blockquote><p>下文中将会从不同的角度</p><h3 id="概率论角度"><a href="#概率论角度" class="headerlink" title="概率论角度"></a>概率论角度</h3><p>首先，需要回忆一下几个概念</p><p>【大数定理】</p>$$\lim_{n\to\infty} \frac{1}{n} \sum_{i=1}^n {X_i} = \mu$$<p>不断的采样一个随机变量，得到n个值，当n趋向于<strong>正无穷</strong>的时候，这个<strong>平均值</strong>就收敛于随机变量的<strong>期望</strong></p><p>【中心极限定理】</p><p>大量<strong>相互独立{条件1</strong>}的随机变量，其均值的分布以<strong>正态分布{结论}</strong>为<strong>极限{条件2}</strong></p><p>【贝叶斯公式】</p><p>默认你已经对<strong>条件概率</strong>了若指掌（在某件事情已经发生的情况下另一件事发生的概率），关于<a href="https://mubu.com/doc/2pJ0IojsIl" target="_blank" rel="external">贝叶斯方法的前世今生</a>，这个链接或许可以帮到你。</p><p>那贝叶斯公式是如何推出来的？</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>我们需要求的问题是：你在校园里面随机游走，遇到了<strong>N个穿长裤的人</strong>（但是可能因为你高度近视你无法看出他们的性别），<strong>问，这N个人里面有多少个女生，多少个男生</strong>，即，穿裤子的人里面有多少个女生</p><h4 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h4>$$穿裤子的人中的女生比例 = \frac{穿长裤的女生人数}{穿长裤的总人数} =\\  \frac {U\times P(Girl)\times P(Paints|Girl)}{U\times P(Boy)\times P(Paints|Boy) + U\times P(Girl)\times P(Paints|Girl)}\tag{1-1}$$化简上式，可以发现其实分母合起来就是 $P(Paints)$ ，分子其实就是既穿裤子又是女孩，整理得$$P(Girl|Paints) = \frac{P(Girl) \times P(Paints|Girl)}{P(Paints)}$$ <p>再一般化，用A表示穿裤子的，B表示女生<br>$$<br>P(B|A) = \frac{P(B)\times P(A|B)}{P(A)} = \frac{P(AB)}{P(A)}\tag{1-2}<br>$$<br>上式就是贝叶斯公式的一般形式，我们在推导中发现，<strong>正常人类对频率的感知和理解速度要高于对概率的</strong>。</p><p>比如“穿长裤的女生人数”这个概念，用总人数乘以<strong>女人比例</strong>，得出<strong>女生人数</strong>，再用女生人数乘以<strong>女生中穿裤子人数的比例</strong>得到<strong>穿裤子的女生人数</strong>。这一串推导感觉毫无困难。但如果读成：在A发生条件下，发成B的概率，会让人乍看下，感到有一定的理解困难。</p><p>我们常说Sense，我觉得这就是一种敏感，对条件概率表达方式的敏感，在你看到的时候，抓住那个最关键的点，不存在任何的迷惑</p><p>那Logistic Function和贝叶斯公式有什么联系呢？</p><p>如果我们把公式（1-1）也符号化，$B_1$ 表示女生，$B_2$表示男生，$A$ 表示穿裤子<br>$$<br>P(B_1|A) = \frac {P(B_1)P(A|B_1)}{P(B_2)P(A|B_2) + P(B_1)P(A|B_1)}\tag{1-3}<br>$$<br>右边同时除以 $P(B_1)\times P(A|B_1)$ ，并定义 $a = \ln{\left( \frac{P(B_1)P(A|B_1)}{P(B_2)P(A|B_2)}\right)}$ 直接由公式(1-3)可得到<br>$$<br>f(a) = \frac{1}{1 + e^{-a}} \tag{1-4}<br>$$<br>很熟悉的形式，其实就是<code>logistic函数</code>的一般形式（对数几率函数），而这个函数的值就是 $f(a)$ ，很明显，<strong>是一个概率</strong></p><p><strong>另一个很重要超级重要的常识就是：正态分布的的累计分布函数（就是从负无穷到x积分）和概率分布函数长得样子很像Logistic累计分布函数和概率密度函数</strong>，可能看到这句话很多人就已经真相大白了，应给无论从中心极限定理出发，还是从统计学概率论角度来看，<strong>概率分布存在的价值是为了描述自然界（现实）中的随机事件，构造函数本身就十分重要，不同的规律需要不同的函数去拟合</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/04/LogisticRegression学习笔记/Normal_distribution.png" alt="正太分布概率密度函数（左）累计密度函数（右）" title="">                </div>                <div class="image-caption">正太分布概率密度函数（左）累计密度函数（右）</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/04/LogisticRegression学习笔记/Logistit_function.png" alt="Logistic函数概率密度函数（左）累计密度函数（右）" title="">                </div>                <div class="image-caption">Logistic函数概率密度函数（左）累计密度函数（右）</div>            </figure><h3 id="统计学角度"><a href="#统计学角度" class="headerlink" title="统计学角度"></a>统计学角度</h3><h4 id="动机-需要解决什么问题"><a href="#动机-需要解决什么问题" class="headerlink" title="动机 - 需要解决什么问题"></a>动机 - 需要解决什么问题</h4><p>在现实生活中，有时候需要探究<strong>某一事件 $A$ 发生的概率 $P$ （0 - 1 之间的一个数）与某些因素 $\mathbf X = (X_1, X_2, \ldots, X_p)’$ 之间的关系</strong>。（其中1到p是各种不同的因素）</p><p>☆ 【<strong>核心问题</strong>】考虑到很多情况下，$P$ 对 $\mathbf X$ 的变化并不敏感，即 $\mathbf X$ 需要发生<strong>很大的变化</strong>才能引起 $P$  的<strong>微弱改变</strong></p><blockquote><p>比如，<u>农药的用量</u>和<u>杀死害虫的概率</u>之间，在农药用量在很小的范围内增长的时候，因为药效不够，杀死害虫的概率增长很慢。</p></blockquote><p>因此，我们要构造一个关于 $P$ 的函数 $\theta(P)$ ，使得它在 $P = 0$ 或 $P = 1$ 附近，$P$ 的微小变化对应 $\theta(P)$ 的较大改变，同时，$\theta(P)$ 要尽可能的简单。于是，我们可以<strong>构造一个函数</strong>（注意：构造函数是数学中很有效的手段，我们需要什么特性就用什么方法来构造一个满足我们需求的函数）c<br>$$<br>\frac {\partial \theta(P)}{\partial P} =\frac{1}{P} +\frac{1}{1-P}<br>$$<br>根据上述公式可以<strong>解得</strong><br>$$<br>\theta(P) =\ln\left(\frac{P}{1-P}\right)<br>$$<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/09/04/LogisticRegression学习笔记/Visualizaiton1.png" alt="可视化" title="">                </div>                <div class="image-caption">可视化</div>            </figure></p><p>这个 $\theta(P)​$ 就是<code>Logit变换</code>，可以看到，这个函数很符合我们的要求： $P = 0​$ 或 $P = 1​$ 附近，$P​$ 的微小变化对应 $\theta(P)​$ 的较大改变</p><h4 id="方案-如何解决这个问题"><a href="#方案-如何解决这个问题" class="headerlink" title="方案 - 如何解决这个问题"></a>方案 - 如何解决这个问题</h4><p>为了建立因变量 $P$ 与自变量 $\mathbf X$ 之间的<strong>合理变动关系</strong>，一个很自然的假设就是<strong>线性关系</strong>，也就是：<br>$$<br>P = \mathbf X’  \boldsymbol{\beta}<br>$$<br>其中 $\boldsymbol \beta = (\beta_1,\beta_1,\ldots,\beta_p)$ 表示每一个不同因素对最终概率 $P$ 产生的影响（这个也可以写作，权重weight）</p><p>由需求可知，在某些情况下，$P = 0$ 或 $P = 1$ 附近，$P$ 对 $\mathbf X$ 的变化并不敏感，简单的线性关系<strong>不能反映这一特征</strong>。此时，构造的  $\theta(P)$ 就派上用场了<br>$$<br>\ln\left(\frac{P}{1-P}\right) = \mathbf X’  \boldsymbol{\beta}<br>$$<br>进行一系列的公式推导有<br>$$<br>\ln\left(\frac{P}{1-P}\right) = \mathbf X^\mathrm T \boldsymbol{\beta} \implies \frac{P}{1-P} = e^{\mathbf X^\mathrm T \boldsymbol{\beta}} \implies P = \frac{e^{\mathbf X^\mathrm T \boldsymbol{\beta}}}{1 + e^{\mathbf X^\mathrm T \boldsymbol{\beta}}}<br>$$<br>则上述最后推出的就是<code>Logistic回归模型</code></p><h3 id="机器学习角度"><a href="#机器学习角度" class="headerlink" title="机器学习角度"></a>机器学习角度</h3><p>周志华《机器学习》，3.3 对数几率回归笔记</p><p>和统计学角度相同，我们的目的是依旧是完成一个<strong>二分类任务</strong>，输出标记 $y \in {0,1}$ ，而线性回归模型产生的预测值 $z = \boldsymbol w^{T}\boldsymbol x + b$ 是实值，于是，我们需要把 z 转换为0/1值，最理想的是<code>单位阶跃函数</code>（unit-step function z &gt; 0➜y=1，z&lt;0➜y=1）</p><p>单单位阶跃函数<strong>不连续</strong>，不能微分，积分，求逆，于是我们希望找到能在一定程度上近似单位阶跃函数的<code>替代函数（surrogate function）</code>，并希望它单调可微，答案很明显，就是<code>对数几率函数（logistic function）</code><br>$$<br>y = \frac{1}{1+e^{-z}}<br>$$</p><p>z 为预测值，y 为输出，<code>对数几率函数</code>是一种<code>Sigmoid函数</code>【一种形状类似S的函数】，将$z = \boldsymbol w^{T}\boldsymbol x + b$ 带入上面的公式</p><p>$$<br>y = \frac{1}{1+e^{-(\boldsymbol w^{T}\boldsymbol x + b)}} \implies \ln(\frac{y}{1-y}) = \boldsymbol w^{T}\boldsymbol x + b<br>$$<br>如果将 $y$ 作为 $\mathbf x$ 作为正例的可能性，$1-y$ 为其反例的可能性<br>$$<br>\frac {y}{1-y}<br>$$<br>上面的式子成为“几率”(odds)：表示 $\mathbf x$ 是正例的<strong>相对可能性</strong>，对odds取对数得到“几率对数”(log odds，也就做logit)</p><h3 id="生态学角度"><a href="#生态学角度" class="headerlink" title="生态学角度"></a>生态学角度</h3><p>可以换一个角度来解读这个问题的前世今生</p><p>1798年的时候一个叫Malthus的英国牧师发现<strong>人口的变化率</strong>和<strong>人口的数目</strong>成正比，需要用数学的手法建立一个公式来表征这个现象，则，使用 $N(t)$ 这个函数来表示<code>t</code>时刻某个地区的<strong>总人口数</strong>（根据<strong>成正比</strong>）<br>$$<br>\frac{dN(t)}{dt} = {rN(t)}<br>$$</p><blockquote><p>其中，<code>r</code>是常数，表示 $N(t)$ 的变化率</p></blockquote><p>直接解出这个方程<br>$$<br>N(t) = N_0e^{rt}<br>$$<br>这很明显是一个指数增长函数，其实也是种群增长的函数表示</p><p>但是问题也是很明显的：种群因为<strong>环境容量</strong>的限制一定是<strong>不能无限增长的</strong>，即，这个模型非常不靠谱，需要重新设计模型来复合现实中的情况。Pierre-François Verhulst 在1838年提出，<strong>构造一个函数</strong><br>$$<br>\frac{dN(t)}{dt} = {rN(t)}\left(1 - \frac{N(t)}{K}\right)<br>$$</p><blockquote><p>K是一个常数，表示系统的容量（capacity）</p></blockquote><p>令 $f(t) = \frac{N(t)}{K}$ ，在方程两边同时除以 $K$ ，上述方程变为：<br>$$<br>\frac{df(t)}{dt} = rf(1 - f)<br>$$<br>这也是<code>Logistic方程</code>的一般形式</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从不同的角度来研究问题就会发现，其实很多时候我们解决一个问题具有一个<strong>相似的模式</strong>，包括<strong>大数定律</strong>，<strong>贝叶斯全概率公式</strong>是一切的基石和解决问题的主要工具</p><p>一个模型的建立规则依据<strong>数据的分布特征</strong>，而这里依托的一个关键信息就是：<strong>在靠近输入0，1两点的时候，y随x的变化不明显</strong>，线性模型没法很好的反应这个特征，所以就构造了一个逻辑回归模型来表示这个特征</p><p>并且<code>Logistic回归模型</code>的<strong>本质</strong>是一个<strong>概率模型</strong>，因为在描述该分类时，我们其实是以概率来衡量的</p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="均方误差-Mean-Squre-Error-MSE"><a href="#均方误差-Mean-Squre-Error-MSE" class="headerlink" title="均方误差 Mean Squre Error MSE"></a>均方误差 Mean Squre Error MSE</h3><p>指参数估计值与参数真值之差平方的<strong>期望值</strong>，是一种目标函数（Objective Function），常用于线性回归<br>$$<br>MSE = \frac{1}{n} \sum_{t = 1}^n{(observed_t - predicted_t)}^2<br>$$</p><h3 id="交叉熵-Cross-Entropy"><a href="#交叉熵-Cross-Entropy" class="headerlink" title="交叉熵 Cross Entropy"></a>交叉熵 Cross Entropy</h3><p>又称为logloss，是Objective function的一种，也称Loss function or Coss Function</p><h4 id="什么是熵"><a href="#什么是熵" class="headerlink" title="什么是熵"></a>什么是熵</h4><p>我觉得这个问题必须搞明白一件事就是：什么是<code>熵 Entropy</code></p><ul><li>广义的定义是：熵是描述一个系统的<strong>无序程度</strong>的变量；同样的表述还有，熵是系统混乱度的度量，一切自发的不可逆过程都是从<strong>有序</strong>到<strong>无序</strong>的变化过程，向熵增的方向进行</li><li>有一个很神奇的解释是：熵字为火字旁加商。当时有位姓胡的学者作为普朗克的防疫。S(entropy)定义为热量Q与温度的<strong>比值</strong>，所以造字：熵</li><li>至于信息论上熵的概念更有意思，有兴趣可以<a href="https://www.zhihu.com/question/22178202/answer/49929786" target="_blank" rel="external">转到</a></li></ul><p>要理解这个<code>Cross Entropy</code>，必须了解它是用来干啥的？</p><p>延伸：<code>信息熵</code> <code>交叉熵</code> <code>相对熵</code>的理解，需要跳转到另一篇笔记：<a href="https://charlesliuyx.github.io/2017/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E6%81%AF%E7%86%B5%E3%80%81%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8C%E7%9B%B8%E5%AF%B9%E7%86%B5/">什么是信息熵、交叉熵和相对熵</a> </p><p>简单来说<code>Cross Entropy</code>可以表示可以度量<strong>最终训练结果于测试集的差异程度</strong>，MSE也是同样的作用。</p><p>换种更具体的说法：我们用p表示真实标记（训练样本标记）的分布，q是训练后的模型的预测标记（输出值标记）的分布，而<strong>交叉熵损失函数可以衡量p与q的相似性</strong>。</p><h4 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h4><p>定义：给定联合样本值 $x$ 关于（未知 - 因为也是一边的自变量）参数 $\theta$ 的函数<br>$$<br>L(\theta|x) = f(x;\theta)<br>$$</p><blockquote><p>$x$ 指联合样本随机变量 $X$ 取到的值，比如天气取值 $X$ =【晴，阴，雨，雪】$x$ = 晴</p><p>$\theta$ 指未知参数，属于参数空间，比如正态分布的均值，方差等</p><p>$f(x;\theta)$ 是<strong>密度函数</strong>，<strong>表示 $\theta$ 参数下</strong>联合样本值 $x$ 的<strong>联合密度函数</strong>（所以这里不用|符号，|符号表达的意思是<strong>条件概率或条件分布</strong>）</p></blockquote><p>从定义上，似然函数和密度函数是完全不同的<strong>两个数学对象</strong>：前者是关于 $\theta$ 的函数，后者是关于 $x$ 的函数。中间的等号理解成<strong>函数值形式相等</strong></p><p>这个等式表示的是对于事件发生的<strong>两种角度的看法</strong>。左边表示概率，右边表示可能性。要表达的含义都是：给定一个样本 $x$ 后，我们去测度这个样本出现的可能性到底有多大。说人话，比如样本空间是 $X =【晴，阴，雨，雪】$，函数表达的就是样本 $x$ = 晴在这个样本空间下发生的概率或可能性</p><p>从<strong>统计学</strong>的角度来说，这个样本的出现一定是<strong>基于一个分布的</strong>（比如二项分布，只正态分布等等），那么我们假设这个分布为 $f(x;\theta)$ ，对于不同的 $\theta$ 样本的分布不一样。</p><p>$f(x;\theta)$ 函数表示的就是在参数 $\theta$ 下 $x$ <strong>出现的概率</strong>有多大（可以带入天气例子思考）</p><p>$L(\theta|x)$ 表示在<strong>给定样本</strong> $x$ ，哪个参数 $\theta$ 使得 $x$ 出现的可能性有多大。说人话，我们已经知道天气是晴天，哪个参数（可能是 $\theta_1$ $\theta_2$）使得这个<strong>函数值最大</strong></p><h4 id="对于Logistic-Regression-为什么要用LogLoss-Cross-Entropy"><a href="#对于Logistic-Regression-为什么要用LogLoss-Cross-Entropy" class="headerlink" title="对于Logistic Regression 为什么要用LogLoss - Cross Entropy"></a>对于Logistic Regression 为什么要用LogLoss - Cross Entropy</h4><p>了解了熵，和似然函数，我们可以开始看看在Logistic Regression的条件下为什么要用LogLoss，换句话也就是说，它一定有它的优势，我们采用，那么它有什么优势？</p><p>Logistic Regression的本质还是一个二分类问题，即Y = 0，or Y = 1</p><p>令 $P(Y=1|x) = \pi(x)$ $P(Y=1|x) = 1 - \pi(x)$ </p><blockquote><p>$y_i$ 表示i次试验，取值就是0 or 1（二分类问题）</p><p>$\pi(x) = \frac{1}{1 + e^{-wx}}$  是Logistic Function的表现形式，其中w相当于似然函数一节提到的 $\theta$ 是需要求的参数（加深理解，其实在二分类问题中，Logistic函数就是一种形式上的概率分布的表现形式）</p></blockquote><p>所以使用基本概率方法可以求解二分类的问题的似然函数<br>$$\ell(w) = \prod_{i = 1}^{N} [\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}$$</p><blockquote><p>注解：说白就和算扔N次硬币，一个连续正反事件串的概率是多少一个含义</p></blockquote><p>看到乘法和指数，第一反应取对数，得到<strong>对数似然函数</strong><br>$$<br>L(w) = \sum_{i=1}^N{[y_ilog_a\pi(x_i) + (1-y_i)log_a(1-\pi(x_i))]}<br>$$</p><p>如果跟随我的步伐走到这一步，你会发现，这个形式，<strong>前半部分是“正例成立”的交叉熵，后半部是“反例成立”的交叉熵</strong>，说实话，叫做交叉熵和二项分布，伯努利过程分不开联系。在上面不远的地方已经详细定义了这几个符号代表的意思</p><p>我们发现，$-\frac{L(w)}{N}$ 就是我们一直使用的Objective function or Loss Function or Cost Function（加负号才是最终的形式）。总之，<strong>训练的目的就是要求能够使得这个函数达到最小的参数</strong>，最终的目的还是<strong>计算出模型参数</strong>，就是 $w$ ，这个参数在上方的统计学角度，和机器学习角度都进行的讨论，重复阅读可以链接这些知识点</p><p>至于LogLoss的好处，一是取对数之后，<strong>乘法边加法，指数放下来</strong>，是凸函数，方便可以寻找最优解。二是<strong>加快了收敛速度</strong>，这里有个形象的步长比喻，可以想象成去了对数后，缩小了尺度，可以让最快梯度下降法要走的距离变短</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】17min - 22min&lt;br&gt;【内容简介】从不同角度解释&lt;strong&gt;为何使用Logistic回归模型&lt;/strong&gt;，解读模型的&lt;strong&gt;现实意义&lt;/strong&gt;，详细解读&lt;strong&gt;为何使用&lt;/strong&gt;以及&lt;strong&gt;什么是&lt;/strong&gt;交叉熵损失函数。并详细梳理符号表达，对公式不再恐惧&lt;/p&gt;
    
    </summary>
    
    
      <category term="BitTiger" scheme="https://charlesliuyx.github.io/tags/BitTiger/"/>
    
      <category term="Theory" scheme="https://charlesliuyx.github.io/tags/Theory/"/>
    
      <category term="Model" scheme="https://charlesliuyx.github.io/tags/Model/"/>
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Xpath使用指南</title>
    <link href="https://charlesliuyx.github.io/2017/08/28/Xpath%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://charlesliuyx.github.io/2017/08/28/Xpath使用指南/</id>
    <published>2017-08-28T19:00:33.000Z</published>
    <updated>2017-09-21T06:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>【阅读时间】查阅类文档<br>【内容简介】Xpath相关使用法法和例子文档，以供查阅（➜ 后是对应语句的输出output）</p><a id="more"></a><h1 id="XPath-相关例子Note"><a href="#XPath-相关例子Note" class="headerlink" title="XPath 相关例子Note"></a>XPath 相关例子Note</h1><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line">sample1 = <span class="string">"""&lt;html&gt;</span></div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;My page&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;h2&gt;Welcome to my &lt;a href="#" src="x"&gt;page&lt;/a&gt;&lt;/h2&gt;</div><div class="line">    &lt;p&gt;This is the first paragraph.&lt;/p&gt;</div><div class="line">    &lt;!-- this is the end --&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">"""</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getxpath</span><span class="params">(html)</span>:</span></div><div class="line">    <span class="keyword">return</span> etree.HTML(html)</div><div class="line">s1 = getxpath(sample1)</div></pre></td></tr></table></figure><p><code>//</code>绝对路径 <code>text()</code> 获取内容中的文字信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s1.xpath(<span class="string">'//title/text()'</span>) ➜ [<span class="string">'My page'</span>]</div></pre></td></tr></table></figure></p><p><code>/</code> 相对路径<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s1.xpath(<span class="string">'/html/head/title/text()'</span>) ➜ [<span class="string">'My page'</span>]</div></pre></td></tr></table></figure></p><p>获取属性<code>src</code>的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s1.xpath(<span class="string">'//h2/a/@src'</span>) ➜ [<span class="string">'x'</span>]</div></pre></td></tr></table></figure></p><p>获取所有属性<code>href</code>的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s1.xpath(<span class="string">'//@href'</span>) ➜ [<span class="string">'#'</span>]</div></pre></td></tr></table></figure></p><p>获取网页中的<strong>所有文本</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">s1.xpath(<span class="string">'//text()'</span>)</div><div class="line">➜</div><div class="line">[<span class="string">'\n  '</span>,</div><div class="line"> <span class="string">'\n    '</span>,</div><div class="line"> <span class="string">'My page'</span>,</div><div class="line"> <span class="string">'\n  '</span>,</div><div class="line"> <span class="string">'\n  '</span>,</div><div class="line"> <span class="string">'\n    '</span>,</div><div class="line"> <span class="string">'Welcome to my '</span>,</div><div class="line"> <span class="string">'page'</span>,</div><div class="line"> <span class="string">'\n    '</span>,</div><div class="line"> <span class="string">'This is the first paragraph.'</span>,</div><div class="line"> <span class="string">'\n    '</span>,</div><div class="line"> <span class="string">'\n  '</span>,</div><div class="line"> <span class="string">'\n'</span>]</div></pre></td></tr></table></figure></p><p>获取网页中的<strong>所有注释</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s1.xpath('//comment()') ➜ [&lt;!-- this is the end --&gt;]</div></pre></td></tr></table></figure></p><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sample2 = <span class="string">"""</span></div><div class="line">&lt;html&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">      &lt;li&gt;Quote 1&lt;/li&gt;</div><div class="line">      &lt;li&gt;Quote 2 with &lt;a href="..."&gt;link&lt;/a&gt;&lt;/li&gt;</div><div class="line">      &lt;li&gt;Quote 3 with &lt;a href="..."&gt;another link&lt;/a&gt;&lt;/li&gt;</div><div class="line">      &lt;li&gt;&lt;h2&gt;Quote 4 title&lt;/h2&gt;Something here.&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">"""</div><div class="line">s2 = getxpath(sample2)</div></pre></td></tr></table></figure><p>获取所有<code>li</code>中的文本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li/text()'</span>) ➜ [<span class="string">'Quote 1'</span>, <span class="string">'Quote 2 with '</span>, <span class="string">'Quote 3 with '</span>, <span class="string">'Something here.'</span>]</div></pre></td></tr></table></figure></p><p>获取第一个 第二个<code>li</code>中的文本，两种写法均可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[position() = 1]/text()'</span>) ➜ [<span class="string">'Quote 1'</span>]</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[1]/text()'</span>) ➜ [<span class="string">'Quote 1'</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[position() = 2]/text()'</span>) ➜ [<span class="string">'Quote 2 with '</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[2]/text()'</span>) ➜ [<span class="string">'Quote 2 with '</span>]</div></pre></td></tr></table></figure><p>奇数 偶数 最后一个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[position() mod2 = 1]/text()'</span>) ➜ [<span class="string">'Quote 1'</span>, <span class="string">'Quote 3 with '</span>]</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[position() mod2 = 0]/text()'</span>) ➜ [<span class="string">'Quote 2 with '</span>, <span class="string">'Something here.'</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[last()]/text()'</span>) ➜ [<span class="string">'Something here.'</span>]</div></pre></td></tr></table></figure><p><code>li</code>下面<code>a</code>中的文本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[a]/text()'</span>) ➜ [<span class="string">'Quote 2 with '</span>, <span class="string">'Quote 3 with '</span>]</div></pre></td></tr></table></figure></p><p><code>li</code>下<code>a</code>或者<code>h2</code>的文本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//li[a or h2]/text()'</span>) ➜ [<span class="string">'Quote 2 with '</span>, <span class="string">'Quote 3 with '</span>, <span class="string">'Something here.'</span>]</div></pre></td></tr></table></figure></p><p>使用 | 同时获取 a 和 h2 中的内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s2.xpath(<span class="string">'//a/text()|//h2/text()'</span>) ➜ [<span class="string">'link'</span>, <span class="string">'another link'</span>, <span class="string">'Quote 4 title'</span>]</div></pre></td></tr></table></figure></p><h2 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sample3 = <span class="string">"""&lt;html&gt;</span></div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">      &lt;li id="begin"&gt;&lt;a href="https://scrapy.org"&gt;Scrapy&lt;/a&gt;begin&lt;/li&gt;</div><div class="line">      &lt;li&gt;&lt;a href="https://scrapinghub.com"&gt;Scrapinghub&lt;/a&gt;&lt;/li&gt;</div><div class="line">      &lt;li&gt;&lt;a href="https://blog.scrapinghub.com"&gt;Scrapinghub Blog&lt;/a&gt;&lt;/li&gt;</div><div class="line">      &lt;li id="end"&gt;&lt;a href="http://quotes.toscrape.com"&gt;Quotes To Scrape&lt;/a&gt;end&lt;/li&gt;</div><div class="line">      &lt;li data-xxxx="end" abc="abc"&gt;&lt;a href="http://quotes.toscrape.com"&gt;Quotes To Scrape&lt;/a&gt;end&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">"""</div><div class="line">s3 = getxpath(sample3)</div></pre></td></tr></table></figure><p>获取 <code>a</code> 标签下 <code>href</code> 以https开始的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s3.xpath(<span class="string">'//a[starts-with(@href, "https")]/text()'</span>) ➜ [<span class="string">'Scrapy'</span>, <span class="string">'Scrapinghub'</span>, <span class="string">'Scrapinghub Blog'</span>]</div></pre></td></tr></table></figure></p><p>获取 <code>href</code>=<a href="https://scrapy.org" target="_blank" rel="external">https://scrapy.org</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s3.xpath(<span class="string">'//li/a[@href="https://scrapy.org"]/text()'</span>) ➜ [<span class="string">'Scrapy'</span>]</div></pre></td></tr></table></figure></p><p>获取 <code>id</code> = begin<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s3.xpath(<span class="string">'//li[@id="begin"]/text()'</span>) ➜ [<span class="string">'begin'</span>]</div></pre></td></tr></table></figure></p><p>获取<code>text</code> = Scrapinghub<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s3.xpath(<span class="string">'//li/a[text()="Scrapinghub"]/text()'</span>) ➜ [<span class="string">'Scrapinghub'</span>]</div></pre></td></tr></table></figure></p><p>获取某个标签下 某个参数 = xx<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s3.xpath(<span class="string">'//li[@data-xxxx="end"]/text()'</span>) ➜ [<span class="string">'end'</span>]</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s3.xpath(<span class="string">'//li[@abc="abc"]/text()'</span>) ➜ [<span class="string">'end'</span>]</div></pre></td></tr></table></figure><h2 id="例子4"><a href="#例子4" class="headerlink" title="例子4"></a>例子4</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">sample4 = <span class="string">u"""</span></div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;My page&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;h2&gt;Welcome to my &lt;a href="#" src="x"&gt;page&lt;/a&gt;&lt;/h2&gt;</div><div class="line">    &lt;p&gt;This is the first paragraph.&lt;/p&gt;</div><div class="line">    &lt;p class="test"&gt;</div><div class="line">    编程语言&lt;a href="#"&gt;python&lt;/a&gt;</div><div class="line">    &lt;img src="#" alt="test"/&gt;javascript</div><div class="line">    &lt;a href="#"&gt;&lt;strong&gt;C#&lt;/strong&gt;JAVA&lt;/a&gt;</div><div class="line">    &lt;/p&gt;</div><div class="line">    &lt;p class="content-a"&gt;a&lt;/p&gt;</div><div class="line">    &lt;p class="content-b"&gt;b&lt;/p&gt;</div><div class="line">    &lt;p class="content-c"&gt;c&lt;/p&gt;</div><div class="line">    &lt;p class="content-d"&gt;d&lt;/p&gt;</div><div class="line">    &lt;p class="econtent-e"&gt;e&lt;/p&gt;</div><div class="line">    &lt;!-- this is the end --&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">"""</div><div class="line">s4 = etree.HTML(sample4)</div></pre></td></tr></table></figure><p>获取 <code>class</code> = test 标签中的<strong>所有</strong>文字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s4.xpath(<span class="string">'//p[@class="test"]/text()'</span>)</div><div class="line">➜ [<span class="string">'\n    编程语言'</span>, <span class="string">'\n    '</span>, <span class="string">'javascript\n    '</span>, <span class="string">'\n    '</span>]</div></pre></td></tr></table></figure></p><p>使用<code>String</code>来获得文字段； <code>strip()</code> 移除字符串收尾字符，默认为空格<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> (s4.xpath(<span class="string">'string(//p[@class="test"])'</span>).strip())</div><div class="line">➜</div><div class="line">编程语言python</div><div class="line">    javascript</div><div class="line">    C<span class="comment">#JAVA</span></div></pre></td></tr></table></figure></p><p>获取所有<code>class</code>属性中<strong>以content开始</strong>的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s4.xpath(<span class="string">'//p[starts-with(@class,"content")]/text()'</span>) ➜ [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div></pre></td></tr></table></figure></p><p>获取所有<code>class</code>属性中<strong>包含</strong>content的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s4.xpath((<span class="string">'//*[contains(@class,"content")]/text()'</span>)) ➜ [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【阅读时间】查阅类文档&lt;br&gt;【内容简介】Xpath相关使用法法和例子文档，以供查阅（➜ 后是对应语句的输出output）&lt;/p&gt;
    
    </summary>
    
    
      <category term="crawl" scheme="https://charlesliuyx.github.io/tags/crawl/"/>
    
  </entry>
  
  <entry>
    <title>PDF复制粘贴去除多余的回车符</title>
    <link href="https://charlesliuyx.github.io/2017/07/29/PDF%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E7%9A%84%E5%9B%9E%E8%BD%A6%E7%AC%A6/"/>
    <id>https://charlesliuyx.github.io/2017/07/29/PDF复制粘贴去除多余的回车符/</id>
    <published>2017-07-30T06:03:08.000Z</published>
    <updated>2017-07-30T07:24:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>直接上解决步骤，但是只能适用于Windows平台，Mac这边可以尝试用<a href="https://www.alfredapp.com/" target="_blank" rel="external">Alfred</a> + workflow来对剪切板操作来解决，或者用<a href="https://www.boastr.net/" target="_blank" rel="external">BetterTouchTool</a>的自带个性化功能来尝试。只是一个思路，没有在Mac系统尝试</p><a id="more"></a> <ul><li>下载 <a href="https://autohotkey.com/download/" target="_blank" rel="external">Autohotkey</a> ，安装（这一步都卡住那估计救不了了）</li><li>桌面右键 ➜ 新建 ➜ 创建新的AutoHotkey Script</li><li>右键创建的文件 ➜ 选择 Edit Script 出来一个记事本</li><li>编辑记事本文件，在已经有的内容下直接加上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#IfWinActive ahk_class classFoxitReader</div><div class="line">^c:: </div><div class="line">    old := ClipboardAll</div><div class="line">    clipboard := &quot;&quot;</div><div class="line">    send ^c</div><div class="line">    clipwait 0.1</div><div class="line">    if clipboard = </div><div class="line">        clipboard := old</div><div class="line">    else &#123;</div><div class="line">        tmp := RegExReplace(clipboard, &quot;(\S.*?)\R(.*?\S)&quot;, &quot;$1 $2&quot;)</div><div class="line">        clipboard := tmp</div><div class="line">        StringReplace clipboard, clipboard, % &quot;  &quot;, % &quot; &quot;, A</div><div class="line">        clipwait 0.1</div><div class="line">        &#125;</div><div class="line">    old := &quot;&quot;</div><div class="line">    tmp := &quot;&quot;</div><div class="line">return</div></pre></td></tr></table></figure><blockquote><p>这里有个问题 <code>IfWinActive ahk_class classFoxitReader</code> 第一行的<code>classFoxitReader</code> 是指的你用什么程序打开PDF </p><p>如果是FoxitReader就是<code>classFoxitReader</code> 如果是Acrobat Adobe就是<code>AcrobatSDIWindow</code></p><p>可以用Autohotkey中的  <a href="https://autohotkey.com/docs/commands/WinGetClass.htm" target="_blank" rel="external">WinGetClass</a> 来获得某一个窗口的<code>ahk_class</code></p></blockquote><ul><li>保存退出</li><li>桌面上双击你刚刚编辑的文件，可以看到右下角出现了一个<code>H</code>形状的图标</li></ul><p>大功告成，这时候你再试试去PDF文档里面<code>ctrl + c</code>就没有回车符了（当然，段落还是无法区分的），也不一定，这一段既然是脚本语言，那就有无限的可能性，就看你的算法实现能力了对吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接上解决步骤，但是只能适用于Windows平台，Mac这边可以尝试用&lt;a href=&quot;https://www.alfredapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Alfred&lt;/a&gt; + workflow来对剪切板操作来解决，或者用&lt;a href=&quot;https://www.boastr.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BetterTouchTool&lt;/a&gt;的自带个性化功能来尝试。只是一个思路，没有在Mac系统尝试&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://charlesliuyx.github.io/tags/Tools/"/>
    
      <category term="Autohotkey" scheme="https://charlesliuyx.github.io/tags/Autohotkey/"/>
    
  </entry>
  
  <entry>
    <title>LeetcodeNote</title>
    <link href="https://charlesliuyx.github.io/2017/07/01/LeetcodeNote/"/>
    <id>https://charlesliuyx.github.io/2017/07/01/LeetcodeNote/</id>
    <published>2017-07-01T07:18:41.000Z</published>
    <updated>2017-07-01T04:53:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>算法培训课程基本模型汇总笔记</p><a id="more"></a><h1 id="线"><a href="#线" class="headerlink" title="线"></a>线</h1><h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h3><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><ul><li>Draw/Equation -&gt; Tree shape</li><li>Define TreeNode <ul><li>本点信息必然是辅助变量，计入TreeNode</li><li>孩子信息决定TreeNode的形状</li><li>任何第一次走的节点，如果不能走，一定要画出来打一把叉</li></ul></li></ul><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">Public <span class="keyword">int</span> <span class="title">func</span><span class="params">(T[] array, V tartget )</span></span>&#123;</div><div class="line"><span class="keyword">int</span> pos = -<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> end array.length - <span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> ( start &lt;= end )&#123;</div><div class="line"><span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</div><div class="line"><span class="keyword">if</span> ( f(a[mid]) &lt;= target )&#123;</div><div class="line">pos = mid;</div><div class="line">start = mid + <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">end = mid - <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Bottom-up-Recursion"><a href="#Bottom-up-Recursion" class="headerlink" title="Bottom up - Recursion"></a>Bottom up - Recursion</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T_P&gt; func(T_v_1, v1 …)&#123;</div><div class="line">checkhastreeNode();</div><div class="line"><span class="keyword">return</span> helper(root(T_v_1, v_1, …))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> &lt;T_P&gt; helper(T_v_1, v1, …)&#123;</div><div class="line">resultchildfirst = helper(childFirst);</div><div class="line">…</div><div class="line">resultchildlast = helper(childLast);</div><div class="line"></div><div class="line">-&gt; result by childs</div><div class="line"><span class="comment">//generate cur node's result;</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFSTree</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Type_R <span class="title">func</span><span class="params">(T_1, e1, T_2, e2)</span></span>&#123;</div><div class="line">checkrootexists();</div><div class="line"></div><div class="line">TreeNode[] array = <span class="keyword">new</span> TreeNode[TREE_HEIGHT];</div><div class="line"></div><div class="line">Stack&lt;TreeNode&gt; stack = Stack&lt;&gt;();</div><div class="line">stack.push(root);</div><div class="line"><span class="keyword">while</span> (!stack.Empty())&#123;</div><div class="line">TreeNode curNode = stack.pop();</div><div class="line"></div><div class="line">Operation at node;</div><div class="line"></div><div class="line">stack.push(childLast);</div><div class="line">…</div><div class="line">stack.push(childFirst);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</div><div class="line">T_V_1 field_1;</div><div class="line">…</div><div class="line">T_V_q field_q;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _height;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> TypeR <span class="title">func</span><span class="params">(T_1 v_1, T_p, v_p)</span> </span>&#123;</div><div class="line">checkexistroot();</div><div class="line"></div><div class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">queue.add(root);</div><div class="line"></div><div class="line"><span class="keyword">while</span> ( !queue.isEmpty() )&#123;</div><div class="line"></div><div class="line"><span class="keyword">int</span> size = queue.size();</div><div class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> I = <span class="number">0</span>; I &lt; size; i++ )&#123;</div><div class="line">TreeNode node = queue.remove();</div><div class="line"></div><div class="line">op at node;</div><div class="line"></div><div class="line">queue.add(childFirst);</div><div class="line">…</div><div class="line">queue.add(childLast);</div><div class="line">&#125;</div><div class="line"></div><div class="line">update var_l,…,var_k <span class="keyword">for</span> next level</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> result;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</div><div class="line">T_1 field_1;</div><div class="line">…</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本模板-1"><a href="#基本模板-1" class="headerlink" title="基本模板"></a>基本模板</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法培训课程基本模型汇总笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://charlesliuyx.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="https://charlesliuyx.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>幕布-全平台笔记思维导图工具</title>
    <link href="https://charlesliuyx.github.io/2017/06/17/%E5%B9%95%E5%B8%83-%E5%85%A8%E5%B9%B3%E5%8F%B0%E7%AC%94%E8%AE%B0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%B7%A5%E5%85%B7/"/>
    <id>https://charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/</id>
    <published>2017-06-17T17:30:47.000Z</published>
    <updated>2017-07-02T06:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>利益相关：幕布深度使用用户</p><p>向大家强烈自来水一款从知乎上了解到的<strong>效率神器</strong>：<strong><a href="https://mubu.com/inv/121749" target="_blank" rel="external">幕布</a></strong>，简直相见恨晚，自从它4月正式上线后就一直使用，对我的日常生活、学习和计划帮助巨大（个人情况：硕士CE在读，ML方向，效率至上主义者，简约UI风格拥护者）</p><p><strong>幕布</strong>是一款<strong>思维管理工具</strong>，可以用来<strong>做笔记</strong>，<strong>梳理思路</strong>，<strong>做待办事项</strong>等等等等。</p><a id="more"></a><p>人类的记忆是有缺陷的，计算机能帮助人进行记忆。我们可以记住大方向的条目，再借助一个<strong>笔记软件</strong>来唤起我们的记忆。<strong>树形结构</strong>是一种极为高效的模式及手段。</p><p>笔记软件很多，思维导图软件很多，但是<strong>能同时满足</strong>以下几点的我找了很久都没有找到，直到遇到<strong>幕布</strong>。如果你和我也有同样的需求，真心的希望这款优秀的软件能帮助到你，提高的你的日常效率，让每一次阅读，每一个计划都高效落地</p><h2 id="UI简约，专注于层次输入本身"><a href="#UI简约，专注于层次输入本身" class="headerlink" title="UI简约，专注于层次输入本身"></a>UI简约，专注于层次输入本身</h2><p>幕布的官网是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/MainPage.webp" alt="幕布官网" title="">                </div>                <div class="image-caption">幕布官网</div>            </figure><p>幕布作为一款笔记软件编辑界面是这样的，幕布专注于<strong>层次化输入</strong>，每一个输入对于幕布来说都是一个<strong>条目</strong>，条目就是我们进行知识梳理的主干</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/EditPage.png" alt="幕布编辑界面" title="">                </div>                <div class="image-caption">幕布编辑界面</div>            </figure><p>每一个操作都<strong>提倡使用快捷键</strong>，拒绝鼠标 + 键盘混用带来的输入思路打断的低效率</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/ShortCut.png" alt="幕布快捷键页面" title="">                </div>                <div class="image-caption">幕布快捷键页面</div>            </figure><h2 id="全平台，云存储和同步，客户端离线编辑"><a href="#全平台，云存储和同步，客户端离线编辑" class="headerlink" title="全平台，云存储和同步，客户端离线编辑"></a>全平台，云存储和同步，客户端离线编辑</h2><p>答主因为同时使用各种设备：12.9寸iPad，Mac，Windows + Linux 台式机和iPhone手机几个工作平台，平常使用电脑进行笔记记录，碎片化时间使用个手机进行背诵记忆等，需要一款全平台的笔记软件。</p><p>而幕布，只要有<strong>浏览器</strong>，有网络就能流畅使用，有离线需求的用户，也可以通过客户端的形式满足日常编辑的需求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/Platform.png" alt="幕布全平台" title="">                </div>                <div class="image-caption">幕布全平台</div>            </figure><h2 id="一键生成思维导图"><a href="#一键生成思维导图" class="headerlink" title="一键生成思维导图"></a>一键生成思维导图</h2><p>选择幕布的重要理由之一，废话不多说，上Gif！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/mindmaps.gif" alt="幕布快捷键页面" title="">                </div>                <div class="image-caption">幕布快捷键页面</div>            </figure><p>用过各种软件，<a href="https://coggle.it/" target="_blank" rel="external">Coggle</a>是UI最漂亮的，但是基本的演示需求幕布完全可以满足，清楚明了</p><hr><p>那么话说回来了，幕布可以用来干什么呢？下面就展示几个主要应用场景（有我自己的，也有来自于<a href="https://mubu.com/doc/explore/55" target="_blank" rel="external">幕布使用趣味案例</a>）</p><p>首先，官网给出了一份<a href="https://mubu.com/doc/explore/56" target="_blank" rel="external">幕布产品引导</a>，其中详细介绍了幕布的使用场景</p><ul><li>读书笔记</li><li>方案计划</li><li>流程说明</li><li>等等</li></ul><hr><p>下面案例一些答主自己日常的一些<strong>特殊</strong>使用场景，基本应用比如做笔记，待办事项，做日程规划等不一一列出来了，就是基本的笔记需求。</p><h2 id="TED演讲笔记"><a href="#TED演讲笔记" class="headerlink" title="TED演讲笔记"></a>TED演讲笔记</h2><p>没有遇到幕布之前，我经常看TED的各种演讲，用于开拓视野，进行英语表达的积累，做笔记的速度太慢，太不方便，遇到幕布之后，我将TED的视频中很关键的内容记录成幕布的条目层次，之后<strong>利用碎片化的时间使用手机客户端进行记忆和背诵</strong>，极大的丰富了我的谈资（<strong>记住的东西才能侃，有条理有依据的说辞才有说服力</strong>）</p><p><a href="https://mubu.com/doc/2LGkymz_vl" target="_blank" rel="external">埃里克 哈世延：下一个科学界大突破是什么</a></p><p>对于这个TED笔记例子</p><ul><li>演讲人大体思路</li><li>经典的<strong>单句</strong>和<strong>例子</strong>（中英文）</li></ul><p>另一方面，因为幕布的全平台特性，我会用碎片化的时间利用电脑端的幕布来进行背诵（TED的演讲内容对于<strong>积累对应领域的英文表达方式</strong>有很大的帮助）</p><h2 id="程序设计和Presentation"><a href="#程序设计和Presentation" class="headerlink" title="程序设计和Presentation"></a>程序设计和Presentation</h2><p>编程前先走流程和功能设计是我平时的习惯，这里有一个很简单的Server-Client模式的练习设计用法：设计程序功能，直接一键思维导图展示，PPT完全不用做了，非常愉悦</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/progd.png" alt="程序Feature" title="">                </div>                <div class="image-caption">程序Feature</div>            </figure><p><img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/progp.png" alt="程序演示"></p><h2 id="Dota2-Wiki"><a href="#Dota2-Wiki" class="headerlink" title="Dota2 Wiki"></a>Dota2 Wiki</h2><p>在国外我发现Dota2维基十分的给力，作为Dota2玩家有一些施法距离，施法机制等有时候需要查看（进阶），但是使用网站一方面内容太多，国内访问实在太慢了，而且<strong>搜索功能</strong>也做的不好，至于我做了什么事情，各位看gif自行感受</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/dota.gif" alt="Dota2" title="">                </div>                <div class="image-caption">Dota2</div>            </figure><p>【利益相关：正在制作，预计Ti7前可以上线，希望也能通过数据帮助到中国军团吧，作为一个做计算机的程序员也希望贡献自己的一份力量】</p><h2 id="期末考试复习"><a href="#期末考试复习" class="headerlink" title="期末考试复习"></a>期末考试复习</h2><p>幕布可以帮助我们把书读薄，我们知道所有的书的特点就是具有层次化，每一本非常优秀的教材都有一套自己对于本学科的<strong>知识体系的理解和层次化抽象</strong>，之前我进行期末复习需要的时间大概是7天左右，有了幕布可以把时间缩减为3天或者更短</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/Final1.png" alt="期末复习笔记总览" title="">                </div>                <div class="image-caption">期末复习笔记总览</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/Final2.png" alt="期末复习笔记具体内容" title="">                </div>                <div class="image-caption">期末复习笔记具体内容</div>            </figure><h2 id="幕布精选"><a href="#幕布精选" class="headerlink" title="幕布精选"></a>幕布精选</h2><p>在幕布里，学习知乎模式，你也可以分享自己中意的作品，获得点赞，在后面讨论，甚至有打赏功能，因为软件本身还很年轻，一切还在发展阶段，对于我本人来说，幕布精选的内容只是锦上添花，我个人不太需求这个功能，但是其中还有一份驾考总结挺有用的，哈哈</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/mubuchoice.png" alt="幕布精选" title="">                </div>                <div class="image-caption">幕布精选</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/06/17/幕布-全平台笔记思维导图工具/mubureward.png" alt="幕布精选打赏功能" title="">                </div>                <div class="image-caption">幕布精选打赏功能</div>            </figure><h2 id="总结和杂七杂八"><a href="#总结和杂七杂八" class="headerlink" title="总结和杂七杂八"></a>总结和杂七杂八</h2><p>我现在的习惯是，只要是读微信公众号的文章，做笔记，读书等，都会用幕布进行记录和整理，感觉提升效率十分明显（节省了我30-40%左右的时间，每天）</p><p>幕布提高我的三个能力</p><ul><li>整理和总结的能力【如何把书读薄】</li><li>层次化思维能力【有组织的整理自己的知识体系和思路模式，加强效率，节省时间】</li><li>背诵能力【全平台（手机），我对碎片化时间能有效利用，我可以多次<strong>重复</strong>背诵需要背诵的内容】</li></ul><p>最后，谢谢你阅读本答案到这个位置，对于我来说，幕布这种层次化的思维模式解决了我当年考高考时候的问题：<strong>什么学习方法是最好的？</strong>我觉得幕布的层次化整理知识的能力就是答案，<strong>幕布提供的是一张纸，一支笔，最后使用幕布能把你的学习生活提升到什么程度，完全取决于你的能力本身</strong>，幕布只是工具，帮助你整理你的大脑，帮你进行背诵，方便查阅。</p><p>工具永远是工作，创造效益的永远是你，未来也是人创造的，不是工具。</p><p>【利益相关，<strong>使用我的幕布分享链接可以获得15天的免费高级版试用机会</strong>，跪求点击注册！hohohohoho】</p><p><a href="https://mubu.com/inv/121749" target="_blank" rel="external">我的分享链接</a> </p><p>幕布，绝对是一个<strong>神器</strong>，希望能帮助到各位，提升效率，创造更大的价值！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利益相关：幕布深度使用用户&lt;/p&gt;
&lt;p&gt;向大家强烈自来水一款从知乎上了解到的&lt;strong&gt;效率神器&lt;/strong&gt;：&lt;strong&gt;&lt;a href=&quot;https://mubu.com/inv/121749&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;幕布&lt;/a&gt;&lt;/strong&gt;，简直相见恨晚，自从它4月正式上线后就一直使用，对我的日常生活、学习和计划帮助巨大（个人情况：硕士CE在读，ML方向，效率至上主义者，简约UI风格拥护者）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幕布&lt;/strong&gt;是一款&lt;strong&gt;思维管理工具&lt;/strong&gt;，可以用来&lt;strong&gt;做笔记&lt;/strong&gt;，&lt;strong&gt;梳理思路&lt;/strong&gt;，&lt;strong&gt;做待办事项&lt;/strong&gt;等等等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="效率工具" scheme="https://charlesliuyx.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
      <category term="幕布" scheme="https://charlesliuyx.github.io/tags/%E5%B9%95%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出看懂AlphaGo如何下棋</title>
    <link href="https://charlesliuyx.github.io/2017/05/27/AlphaGo%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/</id>
    <published>2017-05-27T18:51:22.000Z</published>
    <updated>2017-09-17T23:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>围棋问题，棋盘 <code>19 * 19 = 361</code> 个交叉点可供落子，每个点三种状态，白（用<code>1</code>表示），黑（用<code>-1</code>表示），无子（用<code>0</code>表示），用 $\vec s$ <strong>描述</strong>此时<strong>棋盘的状态</strong>，即棋盘的<strong>状态向量</strong>记为 $ \vec s$ （state首字母）。</p><a id="more"></a><p>$$<br>\vec s = (\underbrace{1,0,-1,\ldots}_{\text{361}})\tag {1-1}<br>$$<br>假设状态 $\vec s$ 下，暂不考虑不能落子的情况， 那么下一步可走的位置空间也是361个。将下一步的<strong>落子行动</strong>也用一个361维的向量来表示，记为 $\vec a$ （action首字母）。<br>$$<br>\vec a = (0,\ldots,0,1,0,\ldots)\tag {1-2}<br>$$<br>公式1.2 假设其中<code>1</code>在向量中位置为<code>39</code>，则  $\vec a$ 表示在棋盘<code>(3,1)</code>位置落<strong>白子</strong>，3为横坐标，1为列坐标</p><p>有以上定义，我们就把围棋问题转化为。</p><blockquote><p>任意给定一个状态  $\vec s$ ，寻找最优的应对策略  $\vec a$ ，最终可以获得棋盘上的最大地盘</p><p>总之</p><p>看到 $\vec s$ ，脑海中就是<strong>一个棋盘，上面有很多黑白子</strong></p><p>看到 $\vec a$ ，脑海中就想象一个人<strong>潇洒的落子</strong></p></blockquote><p>接下来的问题是，如何解决这样一个问题呢？</p><p>先上论文！干货第一</p><p><a href="http://ai.arizona.edu/sites/ai/files/resources/mastering_the_game_of_go_with_deep_neural_networks_and_tree_search.pdf" target="_blank" rel="external">Mastering the game of Go with deep neural networks and tree search</a></p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>首先想到，棋盘也是一幅图像，那么在当时最好用的图像处理算法就是<strong>深度卷积神经网络</strong>（Deep Convolutional Neural Network）。</p><h2 id="深度卷积神经网络——策略函数（Policy-Network）"><a href="#深度卷积神经网络——策略函数（Policy-Network）" class="headerlink" title="深度卷积神经网络——策略函数（Policy Network）"></a>深度卷积神经网络——策略函数（Policy Network）</h2><p>关于什么是<code>CNN</code>，这篇文章十分靠谱，深入浅出的讲解了什么是<code>CNN</code></p><p><a href="http://www.kdnuggets.com/2016/11/intuitive-explanation-convolutional-neural-networks.html" target="_blank" rel="external">An Intuitive Explanation of Convolutional Neural Networks</a> （好像<a href="https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/" target="_blank" rel="external">原地址</a>挂了）（5.29更新，原地址已经恢复，原地址的排版更好，估计之前那个博主在进行博客的整理）</p><p>大致可以理解为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/CNN.png" alt="CNN例子" title="">                </div>                <div class="image-caption">CNN例子</div>            </figure><p>对一副图像进行处理，给定很多样本进行训练，使得最后的神经网络可以获得指定（<strong>具有分类效果</strong>）的输出。</p><p>比如，根据上图可以观察到（这是一个已经训练好的神经网络），最右侧的<strong>输出</strong>是<code>[0.01 , 0.04 , 0.94 , 0.02]</code>，其中第三个值<code>0.94</code>代表的是boat，接近1，所以我们判断这幅图片中有船这个物体（类似的，如果使用这幅图像进行训练，那么<strong>指定</strong>输出应该是[0, 0, 1, 0]，因为图中只有船这个物体）</p><ul><li>在Deep Learning中，卷积层的中的<strong>Filter</strong>也需要<strong>训练</strong>，也就是说<strong>我们使用已有数据来学习图像的关键特征，这样，就可以把网络的规模大幅度的降低</strong></li></ul><p>总而言之，<strong><code>CNN</code>可以帮助我们提取出图像中有实际含义的特征</strong>，那么这和围棋又有什么关系呢？我们来看看Deepmind团队是怎么运用<code>CNN</code>来解决围棋问题。</p><h3 id="深度卷积神经网络解决围棋问题"><a href="#深度卷积神经网络解决围棋问题" class="headerlink" title="深度卷积神经网络解决围棋问题"></a>深度卷积神经网络解决围棋问题</h3><p>2015年，<code>Aja Huang</code>在ICLR的论文<a href="https://arxiv.org/pdf/1412.6564.pdf" target="_blank" rel="external">Move Evaluation in Go Using Deep Convolutional Neural Networks</a>中就提出了如何使用<code>CNN</code>来解决围棋问题。</p><p>他从围棋对战平台KGS上获得了人类选手的围棋对弈棋谱，对于每一个状态 $ \vec s$，都会有一个人类进行 $ \vec a$ 的落子，这也就是一个天然训练样本 $ \langle \vec s,\vec a\rangle $，如此可以得到3000万个训练样本。</p><p>之后，将 $ \vec s$ 看做一个<code>19*19</code>的二维图像（具体实现依据论文输入数据是<code>19*19*48</code>（48是这个位置的其他信息，比如气等信息，激励函数用的 tanh）使用<code>CNN</code>进行训练，目标函数就是人类落子向量 ${\vec a}’$，通过使用海量的数据，不断让计算机接近人类落子的位置。就可以得到一个<strong>模拟</strong>人类棋手下棋的神经网络。</p><p>使用训练的结果，我们可以得到一个神经网络用来计算对于每一个当前棋盘状态 $ \vec s$ ，所对应的落子向量 $ \vec a$ 的概率分布（之所以是概率分布，是因为，计算好的神经网络，输出一般是一个0-1之间的浮点数，越接近1的点表示在这个位置越接近人类的风格，也可以等同于作为人类概率最大的落点。<br>$$<br>\vec a=f(\vec s) \tag{2-1}<br>$$<br>根据公式2.1，我们记 $f()$ 为$P_{human}(\vec s)$ ，论文中也叫做<code>Policy Network</code>，也称策略函数。表示的含义是</p><blockquote><p>在状态 $\vec s$ 下，进行哪一个落子 $\vec a$ 是<strong>最接近人类风格的</strong></p></blockquote><p>计算出来的直观结果，对应到棋盘上如下图，可以看到，红色的区域的值有60%，次大值位于右方，是35%（此图来自于AlphaGo论文）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/PolicyNetwork.png" alt="Policy Network" title="">                </div>                <div class="image-caption">Policy Network</div>            </figure><p>还记得刚刚举得船图的例子嘛？可以类比一下，机器发现现在的状态 $ \vec s$ 和之前的某一种类型有些类似，输出是一个<code>1*361</code>的向量，其中有几个值比较大（接近1就是100%），那么就用这个值当做下一个 $ \vec a$ 的位置。不幸的，这种训练方法有很大的局限的，可以直观想到的是，如果对战平台上数据本身就都是<code>俗手</code>，那不是训练出来一个很蠢的神经网络嘛？棋力如何呢？</p><h3 id="深度卷积网络策略的棋力"><a href="#深度卷积网络策略的棋力" class="headerlink" title="深度卷积网络策略的棋力"></a>深度卷积网络策略的棋力</h3><p>很不幸，据<code>Aja Huang</code>本人说，这个网络的棋力大概相当于业余6段所有的的人类选手。远远未能超过当时最强的围棋电脑程序<code>CrazyStone</code>。</p><p>既然比不过，那么就学习它，<code>Aja Huang</code>打算把 $P_{human}(\vec s)$ 和<code>CrazyStone</code>结合一下，那么问题就来了，    <code>CrazyStone</code>是怎么来解决围棋问题的呢？</p><p>这是<code>Aja Huang</code>的老师<code>Remi Colulum</code>在2006年对围棋AI做出的另一大重要突破</p><p><strong>干货论文送上</strong> MCTS</p><p><a href="https://github.com/papers-we-love/papers-we-love/blob/5a54fa883a813e81b1e54bfed9669fc8961dedb4/artificial_intelligence/efficient-selectivity-and-backup-operators-in-monte-carlo-tree-search.pdf" target="_blank" rel="external">Efficient Selectivity and Backup Operators in Monte-Carlo Tree Search</a></p><h2 id="MCTS-蒙特卡洛搜索树——走子演算（Rollout）"><a href="#MCTS-蒙特卡洛搜索树——走子演算（Rollout）" class="headerlink" title="MCTS 蒙特卡洛搜索树——走子演算（Rollout）"></a>MCTS 蒙特卡洛搜索树——走子演算（Rollout）</h2><p>蒙特卡洛搜索树（Monte-Carlo Tree Search）是一种<em>大智若愚</em>的方法，它的基本思想是：</p><p>首先模拟一盘对决，使用的思路很简单，<strong>随机</strong></p><ul><li>面对一个空白棋盘 $\vec s_0$，最初我们对棋盘一无所知，假设所有落子的方法<strong>分值</strong>都相等，设为<code>1</code></li><li>之后，<strong>【随机】</strong>从<code>361</code>种方法中选一种走法 $\vec a_0$，在这一步后，棋盘状态变为 $\vec s_1$。之后假设对方也和自己一样，<strong>【随机】</strong>走了一步，此时棋盘状态变为 $\vec s_2$</li><li>重复以上步骤直到 $\vec s_n$并且双方分出胜负，此时便完整的模拟完了一盘棋，我们假设一个变量<code>r</code>，胜利记为1，失败则为0</li></ul><p>那么问题就来了，如果这一盘赢了，那意味着这一连串的下法至少比对面那个二逼要明智一些，毕竟我最后赢了，那么我把这次落子方法 $(\vec s_0, \vec a_0)$ 记下来，并把它的分值变化：<br>$$<br>\text{新分数} = \text{初始分数} + r \tag{2-2}<br>$$<br>同理，可以把之后所有随机出来的落子方法 $(\vec s_i, \vec a_i)$ 都应用2-2公式，即都加<code>1</code>分。之后开始第二次模拟，这一次，我们对棋盘不是一无所知了，至少在  $\vec s_0$ 状态我们知道落子方法  $\vec a_0$ 的分值是2，其他都是1，我们使用这个数据的方法是：在这次<strong>随机</strong>中，<strong>我们随机到  $\vec a_0$ 状态的概率要比其他方法高一点</strong>。</p><p>之后，我们不断重复以上步骤，这样，那些看起来不错（以最后的胜负来作为判断依据）的落子方案的分数就会越来越高，并且这些落子方案也是比较有前途的，会被更多的选择。</p>$$score(\vec s) = \begin{pmatrix}r_{11} & r_{12}  & \cdots & r_{1n} \\r_{21} & r_{22}  & \cdots & r_{2n} \\\vdots  & \vdots & \ddots & \vdots \\r_{n1} & r_{n2}  & \cdots & r_{nn} \end{pmatrix}$$<blockquote><p>如上述公式所述，<code>n=19</code>，每一个状态 $\vec s$ 都有一个对应的每个落子点的分数，只要模拟量足够多，那么可以覆盖到的 $\vec s$ 状态就越多，漏洞就越来越小（可以思考李世石的神之一手，是否触及到了AlphaGo1.0的软肋呢？即没有考虑到的状态 $\vec s$ ）</p></blockquote><p>最后，当进行了10万盘棋后，在此状态选择那个<strong>分数最高</strong>的方案落子，此时，才真正下了<strong>这步棋</strong>。这种过程在论文里被称为<strong>Rollout</strong></p><p>蒙特卡洛搜索树的方法十分的深刻精巧，充满的创造力，它有一些很有意思的特点：</p><ul><li>没有任何人工决策的<code>if else</code>逻辑，完全依照规则本身，通过不断的想象（随机）来进行自我对弈，最后提升这一步的质量。有意思的是，其实这也是遵照了人类下棋的思维模式（<strong>模仿</strong>，只是这一次模仿的不是下棋风格，而是人类思考的方式。十分奇妙，人从飞鸟中受到启发发明了飞机，从鱼身上受到启发发明了潜艇，现在，机器学习的程序，通过学习人类使自身发生进化），人类中，水平越高的棋手，算的棋越多，只是人类对于每一个落子的判断能力更加强大，思考中的棋路，也比<strong>随机</strong>方式有效的多，但是机器胜在量大，暴力的覆盖到了很多情况。<em>注意，这一个特点也为之后的提高提供了思路</em>。</li><li>MCTS可是持续运行。这种算法在对手思考对策的时候自己也可以思考对策。在对方思考落子的过程中，MCTS也可以继续进行演算，在对面落子后，在用现在棋盘的情况进行演算，并且之前计算的结果一定可以用在现在情况中，因为对手的下的这步棋，很可能也在之前演算的高分落子选择内。这一点十分像人类</li><li>MCTS是<strong>完全可并行</strong>的算法</li></ul><p><code>Aja Huang</code>很快意识到这种方法的缺陷在哪里：初始策略（或者说<strong>随机的落子方式</strong>）太过简单。就如同上面第一条特点所说，人类对每种  $\vec s$ （棋型）都要更强的判断能力，那么我们是否可以用 $P_{human}(\vec s)$ 来代替随机呢？</p><p><code>Aja Huang</code>改进了MCTS，每一步不使用随机，而是现根据 $P_{human}(\vec s)​$ 计算得到  $\vec a​$ 可能的概率分布，以这儿概率为准来挑选下一个  $\vec a​$。一次棋局下完之后，新分数按照下面的方式来更新<br>$$<br>\text{新分数} = \text{调整后的初始分} + \text{通过模拟的赢棋概率} \tag{2-3}<br>$$<br>如果某一步被随机到很多次，就应该主要依据模拟得到的概率而非 $P_{human}(\vec s)$ ，就是说当盘数不断的增加，模拟得到的结果可能会好于 $P_{human}(\vec s)$ 得到的结果。<br><a name="2-4"></a><br>所以 $P_{human}(\vec s)$ 的初始分会被打个折扣，这也是公式2-3中的调整后的初始分的由来<br> $$\text{调整后的初始分} = \frac{P_{human}(\vec s)}{(\text{被随机到的次数} + 1)} \tag{2-4}$$<br>如此一来，就在整张地图上利用 $P_{human}(\vec s)$ 快速定位了比较好的落子方案，也增加了其他位置的概率。实际操作中发现，此方案不可行，因为计算这个 $P_{human}(\vec s)$ <strong>太慢了太慢了</strong></p><p>一次 $P_{human}(\vec s)$ 的计算需要<code>3ms</code>，随机算法<code>1us</code>，慢了3000倍，所以，<code>Aja huang</code>训练了一个简化版本的 $P_{human-fast}(\vec s)$ ，把神经网络层数、输入特征减少，耗时下降到<code>2us</code>，基本满足了要求。</p><p>更多的，策略是，先以 $P_{human}(\vec s)$ 开局，走前面大概20步，之后再使用 $P_{human-fast}(\vec s)$ 走完剩下的到最后。兼顾速度和准确性。</p><p>综合了深度卷积神经网络和MCTS两种方案，此时的围棋程序已经可以战胜所有其他电脑，虽然和其他人类职业选手还有一定的差距。</p><p>2015年2月，<code>Aja Huang</code>在Deepmind的同事在顶级学术期刊nature上发表的文章 <a href="http://gnusha.org/~nmz787/pdf/Human-level_control_through_deep_reinforcement_learning.pdf" target="_blank" rel="external">Human-level control through deep reinforcement learning</a> 用神经网络打游戏。这篇文章，给AlphaGo提供的了新的方向</p><h2 id="强化学习——局面函数（Value-Network）"><a href="#强化学习——局面函数（Value-Network）" class="headerlink" title="强化学习——局面函数（Value Network）"></a>强化学习——局面函数（Value Network）</h2><p>强化学习（Reinforcement learning）用来实现<strong>左右互搏和自我进化</strong>，首先说说这篇论文干了一件什么事情，Deepmind团队的大牛们使用强化学习的方法在红白机上打通了200多个游戏，大多数得分都要比人好。</p><h3 id="什么是强化学习"><a href="#什么是强化学习" class="headerlink" title="什么是强化学习"></a>什么是强化学习</h3><p>那什么是强化学习呢？这里推荐莫烦大神的 <a href="https://zhuanlan.zhihu.com/p/24807239" target="_blank" rel="external">什么是强化学习</a> 系列教程的知乎专栏，以及另一篇<a href="http://geniferology.blogspot.hk/2015/04/what-is-reinforcement-learning.html" target="_blank" rel="external">强化学习指南</a> 后者对强化学习的基本概念，实现方法进行全面的讲解，含有公式推导。还有两篇我自己做的笔记，<a href="https://mubu.com/doc/WNKomuDNl" target="_blank" rel="external">什么是强化学习</a>，<a href="https://mubu.com/doc/2xNipOEK3l" target="_blank" rel="external">强化学习算法介绍</a></p><p>对于强化学习（Reinforcement learning），它是机器学习的一个分支，特别善於控制一只能够在某个环境下<strong>自主行动</strong>的个体 (autonomous <strong>agent</strong>)，透过和<strong>环境</strong>之间的互动，例如 sensory perception 和 rewards，而不断改进它的 <strong>行为</strong>。</p><p>比如，吃豆人游戏，自主行动的个体就是控制的吃豆人，环境就是迷宫，奖励就是吃到的豆子，行为就是上下左右的操作。</p><p>强化学习的输入是</p><ul><li><strong>状态</strong> (<u>S</u>tates) = 环境，例如迷宫的每一格是一个 state</li><li><strong>动作</strong> (<u>A</u>ctions) = 在每个状态下，有什么行动是容许的</li><li><strong>奖励</strong> (<u>R</u>ewards) = 进入每个状态时，能带来正面或负面的 <strong>价值</strong> (utility)</li></ul><p>输出是</p><ul><li><strong>方案</strong> (<u>P</u>olicy) = 在每个状态下，你会选择哪个行动？也是一个函数</li></ul><p>所以，我们需要根据S，A，R，来确定什么样的P是比较好的，通过不断的进行游戏，获得大量的交互数据，我们可以确定在每一个状态下，进行什么动作能获得最好的分数，而强化学习也就是利用神经网络来拟合这个过程。</p><p>例如，打砖块游戏有一个<strong>秘诀</strong>是把求打到墙后，这样球能自己反弹得分，强化学习程序在玩了600盘后，学到了这个秘诀。也就是说程序会在每一个状态下选择那个更容易把球打到墙后面去的操作。如下图，球快要把墙打穿的时候，评价函数 $v$ 的值会大幅度上升</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/RL.png" alt="打墙游戏的评价函数图" title="">                </div>                <div class="image-caption">打墙游戏的评价函数图</div>            </figure><p>我们可以发现，强化学习的基本思路和MCTS后异曲同工之妙，也是在对游戏完全没有了解的情况，通过不断的训练（进行多盘对弈，和获得进行行动后的分数反馈）来进行训练，自我提升。</p><h3 id="利用强化学习增强棋力"><a href="#利用强化学习增强棋力" class="headerlink" title="利用强化学习增强棋力"></a>利用强化学习增强棋力</h3><p>参考这种思路，<code>Aja Huang</code>给围棋也设计了一个评价函数 $v(\vec s)$ 。此函数的功能是：<strong>量化评估围棋局面</strong>。使用$v(\vec s)$可以让我们在MCTS的过程中<strong>不用走完全局</strong>（走完全盘耗时耗力，效率不高）就发现<strong>已经必败</strong>。</p><p>在利用 $P_{human}(\vec s)$ 走了开局的20步后，<strong>如果有一个 $v(\vec s_i)$ （i为当前状态）可以直接判断是否能赢，得到最后的结果<code>r</code></strong>，不需要搜索到底，可以从效率（剪枝，优化算法时间复杂度）上进一步增加MCTS的威力。</p><p>很可惜的，现有的人类棋谱不足以得出这个评价函数。所以<code>Aja Huang</code>决定用<strong>机器和机器对弈</strong>的方法来创造新的对局，也就是AlphaGo的左右互搏。</p><h3 id="自对弈"><a href="#自对弈" class="headerlink" title="自对弈"></a>自对弈</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/RLArchitecture.png" alt="神经网络的训练过程和结构" title="">                </div>                <div class="image-caption">神经网络的训练过程和结构</div>            </figure><ul><li>先用 $P_{human}(\vec s)$ 和 $P_{human}(\vec s)$ 对弈，比如1万盘，得到1万个新棋谱，加入到训练集中，训练出 $P_{human-1}(\vec s)$ 。</li><li>使用$P_{human-1}(\vec s)$和$P_{human-1}(\vec s)$对弈，得到另1万个新棋谱，加入训练集，训练出$P_{human-2}(\vec s)$。</li><li>同理，进行多次的类似训练，训练出$P_{human-n}(\vec s)$，给最后的新策略命名为$P_{human-plus}(\vec s)$</li></ul><p>（感觉一下，这个$P_{human-plus}(\vec s)$ 应该挺强力的！这里回顾一下$P_{human}(\vec s)$是什么：是一个函数，$\vec a=f(\vec s)$ 可以计算出当前 $\vec s$ 下的落子 $\vec a$ 的分布概率）</p><p>使用$P_{human-plus}(\vec s)$和$P_{human}(\vec s)$进行对弈，发现$P_{human-plus}(\vec s)$胜率80%，自对弈的方法被证明是有效的。（这里有一个想法，我在之前，一直加粗随机，之所以自对弈有效，就是因为整过MCTS过程中从来没有放弃过<strong>随机</strong>，如此一来，大量的计算，就更可能覆盖到更多的可能性，对提高棋力可以产生有效的作用同时。因为概率的问题，不断的自我对弈肯定造成下棋的路数集中，后面也会有体现）</p><p>但是事实并没有那么美好，<code>Aja Huang</code>发现，使用$P_{human-plus}(\vec s)$来代替$P_{human}(\vec s)$进行MCTS反而<strong>棋力会下降</strong>。</p><p><code>Aja Huang</code>认为是$P_{human-plus}(\vec s)$走棋的路数太集中，而MCTS需要更加发散的选择才能有更好的效果。</p><h3 id="计算局部评价函数（Value-Network）"><a href="#计算局部评价函数（Value-Network）" class="headerlink" title="计算局部评价函数（Value Network）"></a>计算局部评价函数（Value Network）</h3><p>考虑到$P_{human-plus}(\vec s)$的下法太过集中，<code>Aja Huang</code>计算 $v(\vec s)$ 的策略是：</p><ul><li>开局先用$P_{human}(\vec s)$走<code>L</code>步，有利于生成更多局面</li><li>即使如此，<code>Aja Huang</code>还是觉得局面不够多样，为了进一步扩大搜索空间，在<code>L+1</code>步时，完全随机一个 $\vec a$ 落子，记下这个状态 $v(\vec s_{L+1})$ </li><li>之后使用$P_{human-plus}(\vec s)$来进行对弈，直到结束时获得结果<code>r</code>，如此不断对弈，由于<code>L</code>也是一个随机数，我们可以得到，<strong>开局、中盘、官子</strong>等不同阶段的很多局面 $\vec s$，和这些局面对应的结果<code>r</code></li><li><p>有了这些训练样本 $\langle \vec s,r\rangle$，还是使用<strong>神经网络</strong>，把最后一层改成<strong>回归</strong>而非<strong>分类</strong>（这里不是用的分类，而是用的<strong>回归，拟合</strong>），就得到了一个 $v(\vec s)$ 来输出<strong>赢棋的概率</strong></p><p><img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/Value Network.png" alt="Value Network"> </p></li></ul><p>如上图所示，$v(\vec s)$ 可以给出下一步落在棋盘上任意位置后，如果双方都用$P_{human-plus}(\vec s)$来走棋，我方赢棋的概率。实验表明，仅仅使用$P_{human}(\vec s)$来训练 $v(\vec s)$ 效果不如$P_{human-plus}(\vec s)$，强化学习是确实有效的。</p><p>总结，<strong>强化学习的$P_{human-plus}(\vec s)$主要是用来获得 $v(\vec s)$ 局部评估函数</strong>。表示的含义是</p><blockquote><p>在状态 $\vec s$ 下，<strong>局面的优劣程度，或者说此时的胜率是多少</strong></p><p> <strong>$v(\vec s)$ 局部评估函数拥有在线下不断自我进化的能力（这也是AlphaGo可以随时间越来越强的最重要的部分）</strong></p></blockquote><p>感谢你看到这里，我们已经拥有：</p><ul><li>$P_{human}(\vec s)$ <code>我的老师是人类！</code></li><li>MCTS <code>乱下，我只看输赢</code></li><li>$v(\vec s)$ <code>我能判断局势</code></li></ul><p>有了这些我们距离AlphaGo已经不远了</p><h2 id="AlphaGo"><a href="#AlphaGo" class="headerlink" title="AlphaGo"></a>AlphaGo</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/MCTS.png" alt="MTCS流程图解" title="">                </div>                <div class="image-caption">MTCS流程图解</div>            </figure><p><code>Aja Huang</code>使用MCTS框架融合局面评估函数 $v(\vec s)$ 的策略是：<br><a name="3-1"></a></p><ul><li>使用$P_{human}(\vec s)$作为初始分开局，每局选择分数最高的方案落子</li><li><p>到第<code>L</code>步后，改用$P_{human-fast}(\vec s)$把剩下的棋局走完，同时调用 $v(\vec s_L)$，评估局面的获胜概率，按照如下规则更新整个树的分数<br>​<br>$$<br>\text{新分数} = \text{调整后的初始分} + 0.5*\text{通过模拟得到的赢棋概率} + 0.5*\text{局面评估分} \tag {3-1}<br>$$</p></li><li><p>前两项和原来一样</p><ul><li>如果待更新的节点就是叶子节点，局面评估分就是 $v(\vec s_L)$ </li><li>如果是待更新的节点是上级节点，局面评估分是该叶子节点 $v(\vec s)$ 的平均值</li></ul></li></ul><p>如果 $v(\vec s)$ 是表示大局观，$P_{human-fast}(\vec s)$表示快速演算，那么上面的方法就是二者的并重，并且<code>Aja Huang</code>团队已经用实验证明0.5 0.5的权重对阵其他权重有95%的胜率</p><h3 id="详解AlphaGo-VS-樊麾-对局走下某一步的计算过程"><a href="#详解AlphaGo-VS-樊麾-对局走下某一步的计算过程" class="headerlink" title="详解AlphaGo VS 樊麾 对局走下某一步的计算过程"></a>详解AlphaGo VS 樊麾 对局走下某一步的计算过程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/Result1.png" alt="详解AlphaGo走某一步棋的过程1" title="">                </div>                <div class="image-caption">详解AlphaGo走某一步棋的过程1</div>            </figure><p><code>a图</code>使用局部评估函数计算出 $\vec s$ 状态下<strong>其他落子点的胜率</strong></p><p><code>b图</code>MCTS中使用<strong>局部评估函数</strong>加 $P_{human}(\vec s)$ 得出的结果</p><p><code>c图</code>MCTS中使用$P_{human}(\vec s)$（复合算法）和$P_{human-fast}(\vec s)$走子走到底的结果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/Result2.png" alt="详解AlphaGo走某一步棋的过程2" title="">                </div>                <div class="image-caption">详解AlphaGo走某一步棋的过程2</div>            </figure><p><code>d图</code>深度卷积神经网络使用<strong>策略函数</strong>计算出来的结果</p><p><code>e图</code>使用<a href="#3-1">公式3-1</a>和相关流程计算出的落子概率</p><p><code>f图</code>演示了AlphaGo和樊麾对弈的计算过程，AlphaGo执黑，樊麾执白。红圈是AlphaGo实际落子额地方。1，2，3和后面的数字表示他想象中的之后樊麾下一步落子的地方。<strong>白色方框</strong>是樊麾的实际落子。在复盘时，樊麾认为1的走法更好（这说明在樊麾落子后AlphaGo也在进行计算）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于<strong>状态数有限</strong>和<strong>不存在随机性</strong>，象棋和五子棋这类游戏理论上可以由终局自底向上的推算出每一个局面的胜负情况，从而得到最优策略。例如五子棋就被验证为<strong>先手必胜</strong>。</p><p>AlphaGo的MCTS属于<strong>启发式搜索算法</strong></p><blockquote><p>启发式搜索算法：由当前局面开始，尝试看起来<u>可靠的行动</u>，达到终局或一定步数后停止，根据后续<u>局面的优劣</u>反馈，选择最有行动。通俗来说，就是”手下一招子，心想三步棋“</p></blockquote><p>围棋是一个NP问题，要穷举的话，解空间巨大。现代优化算法的经典之处在于，从围棋的规则来看，在某一个状态，必定有一个或几个较优解，整个AlphaGo就是想方设法的去找这个较优解。<strong>利用局面评估函数来对MCTS进行剪枝的思路十分精彩</strong>。利用上面的3个算法，结合庞大的并行运算能力，还有<code>Aja Huang</code>团队的辛苦付出，造就了AlphaGo的奇迹。</p><h2 id="使用不同组件AlphGo1-0的棋力"><a href="#使用不同组件AlphGo1-0的棋力" class="headerlink" title="使用不同组件AlphGo1.0的棋力"></a>使用不同组件AlphGo1.0的棋力</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/Result.png" alt="最终棋力结果" title="">                </div>                <div class="image-caption">最终棋力结果</div>            </figure><p>上图显示了各种算法的棋力，Rollout是走棋演算，也就是<code>MCTS</code>，Value Network是 $v(\vec s)$ 局面评估函数，Policy Network 是结合$P_{human-plus}(\vec s)$和$P_{human}(\vec s)$后计算的策略函数（下一步走在哪里胜率高的深度卷积神经网络）</p><p>整个AlphaGo使用的技术，深度卷积网络，强化学习神经网络，都是炙手可热的领域，近年来发展迅猛，日新月异。AlphaGo已经完成了自己历史使命，<strong>借助棋类的巅峰【围棋】为叩门砖打开了机器学习自我进化的大门</strong></p><h2 id="李世石-VS-AlphaGo-1-0——第四局78手挖"><a href="#李世石-VS-AlphaGo-1-0——第四局78手挖" class="headerlink" title="李世石 VS AlphaGo 1.0——第四局78手挖"></a>李世石 VS AlphaGo 1.0——第四局78手挖</h2><p><img src="//charlesliuyx.github.io/2017/05/27/AlphaGo运行原理解析/78.png" width="400" align="center" alt="78"></p><p>赛后AlphaGo之父给出的关键信息：<code>李世石78手“挖”是AlphaGo认为概率极小的点</code>，这一手之后导致的状态 $\vec s$ 进入到了AlphaGo能处理的范围之外，即之前AlphaGo的<strong>自对弈</strong>都是建立用自己觉得好的下法来搜索的，那么如果这一手AlphaGo1.0感觉可能性极小，那么用$P_{human}(\vec s)$自对弈的棋谱中就更加难以覆盖。</p><p>但是也需要提到的是，根据比赛中柯洁等人的观战我们知道，如果不是后面AlphaGo进入了混乱模式，78手不一定是一个好棋。只能说这一手，顶到了AlphaGo的软肋，在真正和人的对局中不一定是“神之一手”</p><p>根据Deepmind团队给出的数据可以知道，一年前，AphaGo1.0的搜索空间，自对弈深度并不完美。所以Deepmind团队有意的在<strong>代码逻辑</strong>上让其<strong>避免打劫</strong>，或者说避免<strong>劫争</strong>，例如，有两个选择，一个胜率60%但需要打劫，另一个55%但不需要打劫，AlphaGo1.0会选择后者。</p><p>那么什么是打劫呢？解释这几个和”劫“有关的围棋术语是：</p><p><code>打劫</code>围棋术语，一方制造事端，和另一方讨价还价的行为。<br><code>劫材</code>可以用来做价格谈判的筹码。通常是走一手没戏，但对手若不予置理，再走第二手会出棋的局部。<br><code>寻劫</code>通过目数计算，寻找一些有价值的局部制造事端强迫对手应答。通常价值至少需要和打劫的地方相当或者小不太多，否则对方很容易消劫。<br><code>利用劫</code>劫胜可杀死对方或者得到利益，劫败也应该让对方付出代价，除非双方劫材大小和数量相差悬殊。</p><p>通俗的说是，我在这一片已经处于劣势，我换一个战场，发动进攻，你应不应？可能在另外战场的角力中对这边战场的局势产生影响。可以类比于，五子棋中的冲四。</p><p>如果有人观看了这一盘棋，我们也可以听到柯洁在强调，AlphaGo在避免打劫，出现了几手莫名其妙的落子。</p><p><strong>总结来说，AlphaGo依靠的是对局外的大量计算，无论是局部评估函数，还是$P_{human-plus}(\vec s)$都十分依赖<font color="#FF0000">对局外</font>的大量的计算。</strong>随着时间的推移，AlphaGo在对局过程需要的时间越来越固定，不需要在对局时进行太多的MCTS搜索就能获得AlphaGo的下一手位置，可以预见，MCTS的搜索深度不会太深。当计算量十分庞大的时候，依赖更多是那个120层的Policy Network。</p><p>从柯洁的第二盘可以发现，他已经努力的制造在中腹引入多方战斗的带劫争的复杂棋局，十分精彩。可惜，AlphaGo2.0貌似已经完善了自己的阿特留斯之踵。当真无敌，说到这里，我们来谈谈AlphaGo2.0</p><h2 id="AlphaGo-2-0-VS-柯洁——虽败犹荣"><a href="#AlphaGo-2-0-VS-柯洁——虽败犹荣" class="headerlink" title="AlphaGo 2.0 VS 柯洁——虽败犹荣"></a>AlphaGo 2.0 VS 柯洁——虽败犹荣</h2><p>三盘对局，感觉到AlphaGo在这一年内进行了极为深度的训练。最可怕的是AlphaGo通过时间<strong>验证了机器学习对于解决NP问题的强大潜力</strong>（通过这三盘可以看出已经无限接近解决了这个问题，至少在对人类上）。甚至：</p><ul><li>臆想一，是否可以利用AlphaGo来<strong>判断规则是否公平</strong>（中国和韩日规则的不同，7目半和6目半）。</li><li>臆想二，最终AlphaGo的自对弈是接近和棋。可惜AlphaGo已经退役。希望针对Deepmind放出的50盘自对弈棋谱可以研究出一些门道，使得围棋这门竞技本身有更大的突破。</li></ul><p><strong>局面函数</strong>和<strong>策略函数</strong>愈发强大，愈加的接近于”围棋之神“。</p><p>随着Google TPU的发布，跑在<code>TPU阵列</code>上的AlphaGo如虎添翼，MCTS的走子演算效率更高，速度更快（加速的其实就是$P_{human-plus}(\vec s)$的落子速度。</p><p>关于TPU的设计思路和原理可以参考 <a href="https://arxiv.org/pdf/1704.04760.pdf" target="_blank" rel="external">In-Datacenter Performance Analysis of a Tensor Processor</a></p><p>对于围棋这个策略单步游戏，是存在<strong>N步最优解</strong>（不存在<code>i+1</code>步最优解），AlphaGo已经在正确的道路上无限的接近于这个<strong>N步最优解</strong>，仿佛在某一步已经看到了你无论怎么下都能走到的N步最优解。</p><p>人类的每一次失误都会使局部评估函数往胜率移动一点，这一点是十分可怕的，因为算法本身的优越性，<strong>大局观</strong>对于AlphaGo的逻辑来说本身就是一种刻在骨子里的基因</p><ul><li>一是因为AlphaGo每次MCTS计算都会计算到接近分出胜负，具有<strong>前瞻性</strong></li><li>二是因为局面函数本身就是为了来统计大局形势定义的，具有<strong>判断局面优劣</strong>的能力</li></ul><p>所谓大局观，不就是这种<strong>走一步看N步的能力</strong>嘛。</p><h2 id="对未来的展望——从AlphaGo想开去"><a href="#对未来的展望——从AlphaGo想开去" class="headerlink" title="对未来的展望——从AlphaGo想开去"></a>对未来的展望——从AlphaGo想开去</h2><p>珍贵的并不是攻克了围棋问题本身，<strong>而是这种解决问题的基本模式</strong>，可以推而广之到很多领域。</p><p>先通过卷积网络学习人类的下法，算出策略函数（Policy Network），再通过<strong>模仿</strong>进行强化学习，左右互搏，不断自我进化，再加上MCTS的经典的解决问题的启发式搜索算法。</p><blockquote><p>这俨然是一个 <strong>模仿➜学习➜优化</strong>的过程</p></blockquote><p>或许，模仿人类，是机器学习最终的归途，至于应用领域方面</p><p>游戏AI是一个最容易想到的领域，只要能抽象出 <code>State</code> <code>Action</code> <code>Judgement</code>，那么这一套解决问题的方式就可以举一反三，让每一个1V1领域的游戏AI非常强大（OpenAI在Dota2 1V1 Solo上的结果更加证明了这一点），至于合作领域的AI可能需要更大的计算量去计算（OpenAI发布的论文<a href="https://blog.openai.com/learning-to-cooperate-compete-and-communicate/" target="_blank" rel="external">MultiAgent</a>很有启发性），对于实际问题来说获得这样的AI有多大的经济价值值得推敲。</p><p>游戏的乐趣就在于<strong>不确定性</strong>，适当的失误也是竞技类游戏的魅力所在，一个能看到<strong>N步最优解</strong>的AI会让一个游戏机制，游戏规则变得可数据化，这一点其实是游戏被创造出来的初衷相背离的。</p><p>其他方面，只要是人类可以学习出来的事物，比如翻译，编程，都是现在的这套体系可能解决的问题，我们期待未来这套<strong>解决问题的方法发挥出无穷的力量</strong>吧！</p><p>[Reference]<br>知乎<a href="https://www.zhihu.com/question/41176911" target="_blank" rel="external">Tao Lei大神的回答</a><br>知乎<a href="https://www.zhihu.com/question/41176911" target="_blank" rel="external">袁行远大神的回答</a><br>知乎<a href="https://www.zhihu.com/question/28655005/answer/61142081" target="_blank" rel="external">有关围棋打劫的回答</a><br>其他文章中引用的论文，链接已经给出</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h1&gt;&lt;p&gt;围棋问题，棋盘 &lt;code&gt;19 * 19 = 361&lt;/code&gt; 个交叉点可供落子，每个点三种状态，白（用&lt;code&gt;1&lt;/code&gt;表示），黑（用&lt;code&gt;-1&lt;/code&gt;表示），无子（用&lt;code&gt;0&lt;/code&gt;表示），用 $\vec s$ &lt;strong&gt;描述&lt;/strong&gt;此时&lt;strong&gt;棋盘的状态&lt;/strong&gt;，即棋盘的&lt;strong&gt;状态向量&lt;/strong&gt;记为 $ \vec s$ （state首字母）。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://charlesliuyx.github.io/categories/Machine-Learning/"/>
    
    
      <category term="AlphaGo" scheme="https://charlesliuyx.github.io/tags/AlphaGo/"/>
    
      <category term="CNN" scheme="https://charlesliuyx.github.io/tags/CNN/"/>
    
      <category term="MCTS" scheme="https://charlesliuyx.github.io/tags/MCTS/"/>
    
      <category term="Deep Learning" scheme="https://charlesliuyx.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>清欢 - 林清玄</title>
    <link href="https://charlesliuyx.github.io/2017/05/14/%E6%B8%85%E6%AC%A2/"/>
    <id>https://charlesliuyx.github.io/2017/05/14/清欢/</id>
    <published>2017-05-14T16:26:55.000Z</published>
    <updated>2017-05-27T03:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>少年时代读到苏轼的一阕词，非常喜欢，到现在还能背诵：</p><blockquote><p>细雨斜风作晓寒，淡烟疏柳媚晴滩，入淮清洛渐漫漫。<br> 雪沫乳花浮午盏，蓼茸蒿笋试春盘，人间有味是清欢。</p></blockquote><a id="more"></a><p>这阕词，苏轼在旁边写着“元丰七年十二月二十四日，从泗州刘倩叔游南山”，原来是苏轼和朋友到郊外去玩，在南山里喝了浮着雪沫乳花的淡茶，配着春日山野里的蓼菜、茼蒿、新笋，以及野草的嫩芽等等，然后自己赞叹着：“人间有味是清欢！”</p><p>当时所以能深记这阕词，最主要的是爱极了后面这一句，因为试吃野菜的这种平凡的清欢，才使人间更有滋味。<strong>“清欢”是什么呢？清欢几乎是难以翻译的，可以说是“清淡的欢愉”，这种清淡的欢愉不是来自别处，正是来自对平静疏淡简朴生活的一种热爱。当一个人可以品味出野菜的清香胜过了山珍海味，或者一个人在路边的石头里看出了比钻石更引人的滋味，或者一个人听林间鸟鸣的声音感受到比提笼遛鸟更感动，或者体会了静静品一壶乌龙茶比起在喧闹的晚宴中更能清洗心灵……这些就是“清欢”。</strong></p><p>清欢之所以好，是因为它对生活的无求，是它不讲求物质的条件，只讲究心灵的品味。“清欢”的境界很高，它不同于李白的<code>人生在世不称意，明朝散发弄扁舟</code>那样的自我放逐；或者<code>人生得意须尽欢，莫使金樽空对月</code>那种尽情的欢乐。它也不同于杜甫的<code>人生有情泪沾臆，江水江花岂终极</code>这样悲痛的心事，或者<code>人生不相见，动如参与商；今夕复何夕，共此灯烛光</code>那种无奈的感叹。</p><p>活在这个世界上，有千百种人生，文天祥的是<code>人生自古谁无死，留取丹心照汗青</code>，我们很容易体会到他的壮怀激烈。欧阳修的是<code>人生自是有情痴，此恨不关风与月</code>，我们很能体会到他的绵绵情恨。纳兰性德的是<code>人到情多情转薄，而今真个不多情</code>，我们也不难会意到他无奈的哀伤。甚至于像王国维的<code>人生只似风前絮，欢也零星，悲也零星，都作连江点点萍！</code>那种对人生无常所发出的刻骨的感触，也依然能够知悉。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>可是“清欢”就难了！</p><p>尤其是生活在现代的人，差不多是没有清欢的。</p><p>什么样是清欢呢？我们想在路边好好的散个步，可是人声车声不断的呼吼而过，一天里，几乎没有纯然安静的一刻。</p><p>我们到馆子里，想要吃一些清淡的小菜，几乎是<strong>杳不可得</strong>，过多的油、过多的酱、过多的盐和味精已经成为中国菜最大的特色，有时害怕了那样的油腻，特别嘱咐厨子白煮一个菜，菜端出来时让人吓一跳，因为菜上挤的色拉比菜还多。</p><p>有时没有什么事，心情上只适合和朋友去<strong>啜一盅茶</strong>、饮一杯咖啡，可惜的是，心情也有了，朋友也有了，就是找不到地方，有茶有咖啡的地方总是嘈杂的。</p><p>俗世里没有清欢了，那么到山里去吧！到海边去吧！但是，<strong>山边和海湄</strong>也不纯净了，凡是人的足迹可以到的地方，就有了垃圾，就有了臭秽，就有了吵闹！</p><p>有几个地方我以前常去的，像阳明山的白云山庄，叫一壶兰花茶，俯望着台北盆地里堆叠着的高楼与人欲，自己饮着茶，可以品到茶中有清欢。像在北投和阳明山间的山路边有一个小湖，湖畔有小贩卖工夫茶，小小的茶几、藤制的躺椅，独自开车去，走过石板的小路，叫一壶茶，在躺椅上静静的靠着，有时湖中的荷花开了，<strong>真是惊艳一山的沉默</strong>。有一次和朋友去，在躺椅上静静喝茶，一下午竟说不到几句话，那时我想，这大概是“人间有味是清欢”了。</p><p>现在这两个地方也不能去了，去了只有伤心。湖里的不是荷花了，是飘荡着的汽水罐子，池畔也无法静静躺着，因为人比草多，石板也被踏损了。到假日的时候，走路都很难不和别人推挤，更别说坐下来喝口茶，如果运气更坏，会遇到呼啸而过的飞车党，还有带伴唱机来跳舞的青年，那时所有的感官全部电路走火，不要说清欢，连欢也不剩了。</p><p>要找清欢，一日比一日更困难了。</p><p>当学生的时候，有一位朋友住在中和圆通寺的山下，我常常坐着颠踬的公交车去找她，两个人沿着上山的石阶，漫无速度的，走走、坐坐、停停、看看，那时圆通寺山道石阶的两旁，杂乱的长着朱槿花，我们一路走，顺手拈下一朵熟透的朱槿花，吸着花朵底部的花露，其甜如蜜，而清香胜蜜，轻轻的含着一朵花的滋味，<strong>心里遂有一种只有春天才会有的欢愉</strong>。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>圆通寺是一座全由坚固的石头砌成的寺院，那些黑而坚强的石头坐在山里仿佛一座不朽的城堡，绿树掩映，清风徐徐，站在用石板铺成的前院里，看着正在生长的小市镇，那时的寺院是澄明而安静的，让人感觉走了那样高的山路，能在那平台上看着远方，就是人生里的清欢了。</p><p>后来，朋友嫁人，到国外去了。我去过一趟圆通寺，山道已经开辟出来，车子可以环山而上，小山路已经很少人走，就在寺院的门口摆着满满的摊贩，有一摊是儿童乘坐的机器马，叽哩咕噜的童歌震撼半山，有两摊是打香肠的摊子，烤烘香肠的白烟正往那古寺的大佛飘去，有一位母亲因为不准孩子吃香肠而揍打着两个孩子，激烈的哭声尖亢而急促……我连圆通寺的寺门都没有进去，就沉默的转身离开，山还是原来的山，寺还是原来的寺，为什么感觉完全不同了，失去了什么吗？失去的正是清欢。</p><p>下山时的心情是不堪的，想到星散的朋友，心情也不是悲伤，只是惆怅，浮起的是一阕词和一首诗，词是李煜的：<code>高楼谁与上？长记秋晴望。往事已成空，还如一梦中！</code>诗是李觏的：<code>人言落日是天涯，望极天涯不见家；已恨碧山相阻隔，碧山还被暮云遮！</code>那时正是黄昏，在都市烟尘蒙蔽了的落日中，真的看到了一种悲剧似的橙色。</p><p>我二十岁心情很坏的时候，就跑到青年公园对面的骑马场去骑马，那些马虽然因驯服而动作缓慢，却都年轻高大，有着光滑的毛色。双腿用力一夹，它也会如箭一般呼噜向前窜去，急忙的风声就从两耳掠过，我最记得的是马跑的时候，迅速移动着的草的青色，青茸茸的，仿佛饱含生命的汁液，跑了几圈下来，一切恶的心情也就在风中、在绿草里、在马的呼啸中消散了。</p><p>尤其是冬日的早晨，勒着绳，马就立在当地，踢踏着长腿，鼻孔中冒着一缕缕的白气，那些气可以久久不散，当马的气息在空气中消弭的时候，人也好像得到某些舒放了。</p><p>骑完马，到青年公园去散步，走到成行的树荫下，冷而强悍的空气在林间流荡，可以放纵的、深深的呼吸，品味着空气里所含的元素，那元素不是别的，正是清欢。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>最近有一天，突然想到骑马，已经有十几年没骑了。到青年公园的骑马场时差一点吓昏，原来偌大的马场已经没有一根草了，一根草也没有的马场大概只有台湾才有，马跑起来的时候，灰尘滚滚，弥漫在空气里的尽是令人窒息的黄土，蒙蔽了人的眼睛。马也老了，毛色斑剥而失去光泽。</p><p>最可怕的是，不知道什么时候在马场搭了一个塑料棚子，铺了水泥地，其丑无比，里面则摆满了机器的小马，让人骑用，其吵无比。为什么为了些微的小利，而牺牲了这个马场呢？</p><p>马会老是我知道的事，人会转变是我知道的事，而在有真马的地方放机器马，在马跑的地方没有一株草，则是我不能理解的事。</p><p>就在马场对面的青年公园，已经不能说是公园了，人比西门町还拥挤吵闹，空气比咖啡馆还坏，树也萎了，草也黄了，阳光也不灿烂了。从公园穿越过去，想到少年时代的这个公园，心痛如绞，别说清欢了，简直像极了佛经所说的“<strong>五浊恶世</strong>”！</p><p>生在这个时代，为何“清欢”如此难觅。眼要清欢，找不到青山绿水；耳要清欢，找不到宁静和谐；鼻要清欢，找不到干净空气；舌要清欢，找不到蓼茸蒿笋；身要清欢，找不到清凉净土；意要清欢，找不到<strong>智慧明心</strong>。如果要享受清欢，唯一的方法是守在自己小小的天地，洗涤自己的心灵，因为在我们拥有愈多的物质世界，我们的清淡的欢愉就日渐失去了。</p><p>现代人的欢乐，是到<strong>油烟爆起、卫生堪虑</strong>的啤酒屋去吃炒蟋蟀；是到黑天暗地、不见天日的卡拉OK去乱唱一气；是到乡村野店、胡乱搭成的土鸡山庄去豪饮一番；以及到狭小的房间里做方城之戏，永远重复着摸牌的一个动作……这些放逸的生活以为是欢乐，想起来<strong>毋宁</strong>是可悲的。为什么现代人不能过清欢的生活，反而以浊为欢，以清为苦呢？</p><p>一个人以浊为欢的时候，就很难体会到生命清明的滋味，而在欢乐已尽、浊心再起的时候，人间就愈来愈无味了。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>这使我想起东坡的另一首诗来：</p><blockquote><p>梨花淡白柳深青，柳絮飞时花满城；<br> 惆怅东栏一株雪，人生看得几清明？</p></blockquote><p>苏轼凭着东栏看着栏杆外的梨花，满城都飞着柳絮时，梨花也开了遍地，东栏的那株梨花却从深青的柳树间伸了出来，仿佛雪一样的清丽，有一种惆怅之美，但是人生看这么清明可喜的梨花能有几回呢？这正是千古风流人物的性情，这正是清朝大画家盛大士在《溪山卧游录》中说的<code>凡人多熟一分世故，即多一分机智。多一分机智，即少却一分高雅。</code> 也有说<code>山中何所有？岭上多白云，只可自怡悦，不堪持赠君，自是第一流人物。</code></p><p>第一流人物是什么人物？</p><p>第一流人物是在<span style="color:red">清欢里也能体会人间有味</span>的人物！</p><p>第一流人物是<span style="color:red">在污浊滔滔的人间，也能找到清欢的人物！</span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p&gt;少年时代读到苏轼的一阕词，非常喜欢，到现在还能背诵：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;细雨斜风作晓寒，淡烟疏柳媚晴滩，入淮清洛渐漫漫。&lt;br&gt; 雪沫乳花浮午盏，蓼茸蒿笋试春盘，人间有味是清欢。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://charlesliuyx.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>English-abbreviation</title>
    <link href="https://charlesliuyx.github.io/2017/05/13/English-abbreviation/"/>
    <id>https://charlesliuyx.github.io/2017/05/13/English-abbreviation/</id>
    <published>2017-05-14T00:29:00.000Z</published>
    <updated>2017-05-26T05:35:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些常用的英语缩写的总结</p><a id="more"></a><h2 id="日常生活篇"><a href="#日常生活篇" class="headerlink" title="日常生活篇"></a>日常生活篇</h2><ol><li><code>R.S.V.P</code>: 源自于法语‘Répondez s’il vous plait’，英文解释为’Respond,if you please’.邀请函结尾写这个，表示‘敬请回复’；</li><li><code>P.S</code>: 意思是‘post script’,表示‘再多说一句’，一般写完要说的话之后结尾突然想起说什么可以写；</li><li><code>ASAP</code>: as soon as possible. 表示‘尽快’，注意听音频发音，可读成A-SAP;</li><li><code>ETA</code>: estimated time of arrival. 表示‘预计到达时间’；</li><li><code>BYOB</code>: bring your own bottle; 表示‘自带酒水，举办派对时常用’</li></ol><h2 id="吃饭做菜篇"><a href="#吃饭做菜篇" class="headerlink" title="吃饭做菜篇"></a>吃饭做菜篇</h2><ol><li><code>tsp or t</code> : teaspoon 一茶匙</li><li><code>tbs / tbsp/ T</code>: tablespoon 一汤匙</li><li><code>c</code>: cup 一杯</li><li><code>gal</code>: gallon 加仑</li><li><code>lb</code> : pound 磅</li><li><code>pt</code>：pint 品脱</li><li><code>qt</code>: quart 夸脱</li></ol><h2 id="出国地图篇"><a href="#出国地图篇" class="headerlink" title="出国地图篇"></a>出国地图篇</h2><ol><li><code>Ave</code>: avenue 大街</li><li><code>Blvd</code>: boulevard 大道</li><li><code>Ln</code>: lane 车道</li><li><code>Rd</code>: road 公路</li><li><code>St</code>: street 街道</li></ol><h2 id="教育工作篇"><a href="#教育工作篇" class="headerlink" title="教育工作篇"></a>教育工作篇</h2><ol><li><code>BA</code>: Bachelor of Arts 文学士</li><li><code>BS</code>: Bachelor of Science 理学士</li><li><code>MA</code>: Master of Arts 文科硕士</li><li><code>PA</code>: Personal Assistant 私人助理</li><li><code>VP</code>: Vice President 副总统;副总裁</li><li><code>CEO</code>: Chief Executive Officer 首席执行官</li><li><code>CFO</code>: Chief Financial Officer 首席财务官</li><li><code>COO</code>: Chief Operating Officer 首席运营官</li><li><code>CMO</code>: Chief Marketing Officer 首席营销官</li></ol><h2 id="社交聊天篇"><a href="#社交聊天篇" class="headerlink" title="社交聊天篇"></a>社交聊天篇</h2><ol><li><code>JK</code> :just kidding 跟你开玩笑呢</li><li><code>TBD</code>: to be determined 待定</li><li><code>AFAIK</code>: as far as I know 据我所知</li><li><code>BRB</code>: be right back 马上回来</li><li><code>CUL</code>: see you later 回见</li><li><code>TTYL</code>: talk to you later 回聊</li><li><code>CWYL</code>: chat with you later 回聊</li><li><code>LOL</code>: laugh out loud 哈哈</li><li><code>LMAO</code>: laugh my ass off 笑死我了</li><li><code>ROTFL/ ROFL</code>: rolling on the floor laughing 笑到在地上打滚</li><li><code>NP</code>: no problem 没问题,没关系,不客气</li><li><code>IDK</code>: I don’t know 我不知道</li><li><code>ILY</code>: I love you 我爱你</li><li><code>TMI</code>: too much information 信息量太大了； 说的太多了</li><li><code>OIC</code>: Oh, I see. 我明白了</li><li><code>FYI</code>: for your information 顺便告知你</li><li><code>BTW</code>: by the way 顺便说一下 顺便问一下</li><li><code>MYOB</code>: mind your own business 别多管闲事</li><li><code>FAQ</code>: frequently asked questions 经常被问的问题<br>20: <code>WTF</code>: what the fuck 搞毛阿…… 委婉的是WTH: what the hell/heck<br>21: <code>AKA</code>: also known as. 也叫做</li><li><code>TGIF</code>: thank god It’s Friday 谢天谢地又到礼拜五了</li><li><code>TBC</code>: to be continued; to be confirmed 未完待续/ 有待确认</li></ol><h2 id="数字字母篇"><a href="#数字字母篇" class="headerlink" title="数字字母篇"></a>数字字母篇</h2><p><code>2</code>: to/too<br><code>4</code>: for<br><code>B</code>: be<br><code>C</code>: see<br><code>I</code>: eye<br><code>O</code>: owe;<br><code>R</code>: are;<br><code>U</code>: you;<br><code>ur</code>: your/you’re<br><code>Y</code>: why</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些常用的英语缩写的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="英语积累" scheme="https://charlesliuyx.github.io/tags/%E8%8B%B1%E8%AF%AD%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>有关中国诗的那些事</title>
    <link href="https://charlesliuyx.github.io/2017/05/13/%E6%9C%89%E5%85%B3%E4%B8%AD%E5%9B%BD%E8%AF%97%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://charlesliuyx.github.io/2017/05/13/有关中国诗的那些事/</id>
    <published>2017-05-13T23:40:00.000Z</published>
    <updated>2017-05-26T05:34:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>没有沉淀，文字永远上不了档次。难得空闲，读了些诗，有些感受。</p><h3 id="韦应物"><a href="#韦应物" class="headerlink" title="韦应物"></a>韦应物</h3><a id="more"></a><blockquote><p>独怜幽草涧边生，上有黄鹂深树鸣。春潮带雨晚来急，野渡无人舟自横。</p></blockquote><p>记起这《滁州西涧》，听过一个故事。话说一次国画比赛，题目是以<code>春潮带雨晚来急，野渡无人舟自横</code>这句诗作画。国学博大精深，国画作为其中一支配起诗来，别有遐想。此题甚好，不仅考及画技，更有对国学中诗词的体悟和见解。大家不妨也想想如果是你，你会怎么画？这里先卖个关子。</p><p>从诗的字面来说，是这样一种通感：春天近了，潮气依稀可嗅。但谁能像你这样，对一棵在水边生长的小草也充满爱怜？黄鹂在密林深处的低语你都能听到？这需要多么细腻的一颗心。华灯初上，渡口上已经没有人，舟独自横于水上，那是一种空阔的感觉。映照你一生步履，你的细腻出于岁月。你当年49岁，50载，可能不长，但是我知道你的与众不同，你的50载甚至顶得别人几辈子。</p><p>韦应物年少荒唐，并未认真读书。安史乱起，韦应物扈从不及，流落秦中。乱后，韦应物折节读书，痛改前非，从一个富贵无赖纨绔一变而为忠厚仁爱的儒者。有些官运，在地方（苏州）任官。韦应物勤于吏职，简政爱民，在苏州刺史届满之后，一贫如洗，寄居无定寺，客死他乡。 享年五十五岁。</p><p>别人些许看出的是你不在其位，不得其用的无奈，忧伤。但我看到的，更多是你的豁达，你心中总是美好多于忧伤。</p><p>通往远方的路，没有哪条是你不能走的；走在路上的人，没有谁是你不能结交的；结交的朋友，没有谁是你不能推心置腹的。虽然那个时代远没有现在的复杂，但是能捧出一颗完整的心也并不是一件容易的事。韦苏州，你是一个充满诗情的人。</p><p>回头看看开头提到的国画比赛优胜者的作品：弥蒙的雾气用模糊的淡墨衬托，远处的群山，夕阳露出半个头。远远的有几簇灯火，近处，一条小舟在几根芦苇中飘荡，船上有位着布衣的蓑翁，嘴里叼根芦苇，帽檐下压，不知是否在闭目养神，两只杜鹃立于船头。起初不懂，“无人”的野渡为何有人呢？其中深意，结合了韦苏州的履历才恍然大悟。</p><p>“无人”并不是一只孤舟。韦应物闲居，船上舟子，好似当时的韦应物，在船头打盹，闻着草香，听着鹂鸣。韦应物虽然赋闲苏州，但他并不排斥官场，若有机会，他还是会出仕，只是满足于闲暇。无奈忧伤可能有，但经历了顽劣，奋起，战乱，官场，贬谪，闲居的韦应物，更多的，是看破人生的豁达和满足。</p><h3 id="李白"><a href="#李白" class="headerlink" title="李白"></a>李白</h3><p>总觉中国诗总离不开一个“愁”字。思乡，思亲，忧国，羁旅等等，都和“愁”万缕千丝。我爱这些无奈，悲壮，不舍，甚至愤懑，嘲讽。他们仿佛缩影了人生，视角令人称奇，细腻的令你悸动。</p><p><strong>抽刀断水，是最无奈的神话；举杯消愁，是最动情的悲歌。</strong>李白潇洒一生，他豪放，甚至一直清贫，有了几个钱，就豪饮一番，将诗情挥洒，更是对“愁”下了如此入理的定义。</p><p><code>拣尽寒枝不肯栖，寂寞沙洲岭</code>李白就犹如谪仙，似乎从来没有受过来自这个世界的温暖。于是，在静夜里，李白写下了<code>床前明月光，疑是地上霜。举头望明月，低头思故乡</code>的千古“愁”词。可是李白的故乡在哪里呢？是陇西？是巴蜀？月华似霜的夜，浪迹天涯的游子李白在梦幻中寻觅故乡，但故乡却比梦幻更飘渺。</p><p>李白是复杂的，李白糅合着道家的“出世”和儒家的“入世”思想。所以，顺境时，他<code>仰天大笑出门去，我辈岂是蓬蒿人</code>的潇洒豪情；逆境时，他有<code>弃我去者昨日之日不可留，乱我心者今日之日多烦忧</code>的绵绵愁绪。   </p><h3 id="那些诗人"><a href="#那些诗人" class="headerlink" title="那些诗人"></a>那些诗人</h3><p>感动于张谓笔下早梅傲雪<code>不知近水花先发，疑是经冬雪未消</code>的玄妙；<br>陶醉于贺铸风中<code>一川烟草，满城风絮，梅子黄时雨</code>的飘愁；<br>哀婉于苏轼眼中<code>细看来，不是杨花，点点是，离人泪</code>的破碎。</p><p>说起苏东坡，一个传奇。</p><p><code>人生如梦</code>，东坡曾经迷惘过；<code>早生华发</code>，东坡曾经惋惜过；<code>十年生死两茫茫</code>，东坡曾经痛苦过。但他不屈，他平和，他豁达。</p><p><code>一蓑烟雨任平生</code>，他淡泊；<code>日啖荔枝三百颗，不辞长作岭南人</code>，他自定；<code>踏雪飞鸿</code>，他淡然。<code>问汝平生功业，黄州惠州儋州</code>，三贬之地，还恰恰就是他留下许多不朽之作的地方。</p><p>读着这些诗，深深思索，你会感到作为一个中国人学会了中文，有着五千年的浩瀚历史文化，是多么令你振奋和自豪；国学，遗留的东西，值得我们用一生去参悟。常说高考诗词理解令人头痛，如果怀着这样的心情读诗，你还会怕吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有沉淀，文字永远上不了档次。难得空闲，读了些诗，有些感受。&lt;/p&gt;
&lt;h3 id=&quot;韦应物&quot;&gt;&lt;a href=&quot;#韦应物&quot; class=&quot;headerlink&quot; title=&quot;韦应物&quot;&gt;&lt;/a&gt;韦应物&lt;/h3&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://charlesliuyx.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
